"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = CommandFactory;
exports.Command = void 0;

var _events = require("events");

var _child_process = require("child_process");

var _path = _interopRequireDefault(require("path"));

var _fs = _interopRequireDefault(require("fs"));

var _option = _interopRequireDefault(require("./option"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Pad `str` to `width`.
 *
 * @param str
 * @param width
 * @returns
 */
function pad(str, width) {
  const len = Math.max(0, width - str.length);
  return str + Array(len + 1).join(' ');
}
/**
 * Output help information if necessary
 *
 * @param command - the command to output help for
 * @param options - an array of options to search for `-h` or `--help`
 */


function outputHelpIfNecessary(cmd, options = []) {
  for (let i = 0; i < options.length; i++) {
    if (options[i] === '--help' || options[i] === '-h') {
      cmd.outputHelp();
      process.exit(0);
    }
  }
}
/**
 * Takes an argument an returns its human readable equivalent for help usage.
 *
 * @param arg
 * @returns
 */


function humanReadableArgName({
  name,
  variadic,
  required
}) {
  const nameOutput = name + (variadic === true ? '...' : '');
  return required ? `<${nameOutput}>` : `[${nameOutput}]`;
}
/**
 * Detect whether current command line input infers an option.
 *
 * @param normalized option rules
 * @param typed args
 * @returns active option if found, otherwise false
 */


function autocompleteActiveOption(optionRules, typedArgs) {
  if (typedArgs.length === 0) {
    return false;
  }

  const lastArg = typedArgs[typedArgs.length - 1];

  if (!optionRules[lastArg]) {
    return false;
  }

  const option = optionRules[lastArg];

  if (option.arity === 0) {
    return false;
  }

  return option;
}
/**
 * Detect whether current command line input infers an arg.
 *
 * @param normalized option rules
 * @param normalized arg rules
 * @param typed args
 * @returns active arg if found, otherwise false
 */


function autocompleteActiveArg(optionRules, argRules, typedArgs) {
  if (argRules.length === 0) {
    return false;
  } // find out how many args have already been typed


  let count = 0;
  let curr = 0;

  while (curr < typedArgs.length) {
    const currStr = typedArgs[curr];

    if (optionRules[currStr]) {
      curr += optionRules[currStr].arity + 1;
    } else {
      count += 1;
      curr += 1;
    }
  }

  if (argRules.length > count) {
    return argRules[count];
  }

  return false;
}
/**
 * A command builder
 * @noInheritDoc
 */


class Command extends _events.EventEmitter {
  /**
   * The running node process from running a subcommand executable
   */
  constructor(name = '') {
    super();

    _defineProperty(this, "commands", []);

    _defineProperty(this, "options", []);

    _defineProperty(this, "executables", void 0);

    _defineProperty(this, "defaultExecutable", void 0);

    _defineProperty(this, "parent", void 0);

    _defineProperty(this, "args", void 0);

    _defineProperty(this, "runningCommand", void 0);

    _defineProperty(this, "rawArgs", void 0);

    _defineProperty(this, "noHelp", void 0);

    _defineProperty(this, "execs", {});

    _defineProperty(this, "argsDescription", void 0);

    _defineProperty(this, "_alias", void 0);

    _defineProperty(this, "_allowUnknownOption", false);

    _defineProperty(this, "_args", []);

    _defineProperty(this, "_version", void 0);

    _defineProperty(this, "_description", void 0);

    _defineProperty(this, "_usage", void 0);

    _defineProperty(this, "_name", void 0);

    _defineProperty(this, "versionOptionName", void 0);

    _defineProperty(this, "_completionRules", {
      options: {},
      args: []
    });

    this._name = name;
  }
  /**
   * Add command `name`.
   *
   * The [[action]] callback is invoked when the
   * command `name` is specified via __ARGV__,
   * and the remaining arguments are applied to the
   * function for access.
   *
   * When the `name` is "*" an un-matched command
   * will be passed as the first arg, followed by
   * the rest of __ARGV__ remaining.
   *
   * Examples:
   * ```ts
   * const prog = program()
   *   .version('0.0.1')
   *   .option('-C, --chdir <path>', 'change the working directory')
   *   .option('-c, --config <path>', 'set config path. defaults to ./deploy.conf')
   *   .option('-T, --no-tests', 'ignore test hook')
   *
   * prog
   *   .command('setup')
   *   .description('run remote setup commands')
   *   .action(() => {
   *     console.log('setup');
   *   });
   *
   * prog
   *   .command('exec <cmd>')
   *   .description('run the given remote command')
   *   .action((cmd) => {
   *     console.log('exec "%s"', cmd);
   *   });
   *
   * prog
   *   .command('teardown <dir> [otherDirs...]')
   *   .description('run teardown commands')
   *   .action((dir, otherDirs) => {
   *     console.log('dir "%s"', dir);
   *     if (otherDirs) {
   *       otherDirs.forEach((oDir) => {
   *         console.log('dir "%s"', oDir);
   *       });
   *     }
   *   });
   *
   * prog
   *   .command('*')
   *   .description('deploy the given env')
   *   .action((env) => {
   *     console.log('deploying "%s"', env);
   *   });
   *
   * prog.parse(process.argv);
   * ```
   *
   * @param name
   * @param [desc] for git-style sub-commands
   * @returns [[Command]] the new command
   */


  command(name, desc, opts = {
    isDefault: false,
    noHelp: false
  }) {
    if (typeof desc === 'object' && desc != null) {
      opts = desc;
      desc = null;
    }

    opts = opts || {};
    const args = name.split(/ +/);
    const cmd = new Command(args.shift());

    if (desc && cmd._name) {
      cmd.description(desc);
      this.executables = true;
      this.execs[cmd._name] = true;

      if (opts.isDefault) {
        this.defaultExecutable = cmd._name;
      }
    }

    cmd.noHelp = !!opts.noHelp;
    this.commands.push(cmd);
    cmd.parseExpectedArgs(args);
    cmd.parent = this;
    if (desc) return this;
    return this;
  }
  /**
   * Define argument syntax for the top-level command.
   */


  arguments(desc) {
    return this.parseExpectedArgs(desc.split(/ +/));
  }
  /**
   * Add an implicit `help [cmd]` subcommand
   * which invokes `--help` for the given command.
   */


  addImplicitHelpCommand() {
    this.command('help [cmd]', 'display help for [cmd]');
  }
  /**
   * Parse expected `args`.
   *
   * For example `["[type]"]` becomes `[{ required: false, name: 'type' }]`.
   */


  parseExpectedArgs(args) {
    if (!args.length) this;
    args.forEach(arg => {
      const argDetails = {
        required: false,
        name: '',
        variadic: false
      };

      switch (arg[0]) {
        case '<':
          argDetails.required = true;
          argDetails.name = arg.slice(1, -1);
          break;

        case '[':
          argDetails.name = arg.slice(1, -1);
          break;
      }

      if (argDetails.name.length > 3 && argDetails.name.slice(-3) === '...') {
        argDetails.variadic = true;
        argDetails.name = argDetails.name.slice(0, -3);
      }

      if (argDetails.name) {
        this._args.push(argDetails);
      }
    });
    return this;
  }
  /**
   * Register a callback for a command
   *
   * Examples:
   * ```ts
   * program()
   *   .command('help')
   *   .description('display verbose help')
   *   .action(() => {
   *      // output help here
   *   });
   * ```
   * @param fn
   * @returns [[Command]] for chaining
   */


  action(fn) {
    const listener = (args = [], unknown = []) => {
      const parsed = this.parseOptions(unknown); // Output help if necessary

      outputHelpIfNecessary(this, parsed.unknown); // If there are still any unknown options, then we simply
      // die, unless someone asked for help, in which case we give it
      // to them, and then we die.

      if (parsed.unknown.length > 0) {
        this.unknownOption(parsed.unknown[0]);
      } // Leftover arguments need to be pushed back. Fixes issue #56


      if (parsed.args.length) args = parsed.args.concat(args);

      this._args.forEach((arg, i) => {
        if (arg.required && args[i] == null) {
          this.missingArgument(arg.name);
        } else if (arg.variadic) {
          if (i !== this._args.length - 1) {
            this.variadicArgNotLast(arg.name);
          }

          args[i] = args.splice(i);
        }
      }); // Always append ourselves to the end of the arguments,
      // to make sure we match the number of arguments the user
      // expects


      if (this._args.length) {
        args[this._args.length] = this;
      } else {
        args.push(this);
      }

      fn.apply(this, args);
    };

    const parent = this.parent || this;
    const name = parent === this ? '*' : this._name;
    parent.on(`command:${name}`, listener);
    if (this._alias) parent.on(`command:${this._alias}`, listener);
    return this;
  }
  /**
   * Define option with `flags`, `description` and optional
   * coercion `fn`.
   *
   * The `flags` string should contain both the short and long flags,
   * separated by comma, a pipe or space. The following are all valid
   * all will output this way when `--help` is used.
   *
   * * "-p, --pepper"
   * * "-p|--pepper"
   * * "-p --pepper"
   *
   * Examples:
   * ```ts
   * // simple boolean defaulting to false
   * program.option('-p, --pepper', 'add pepper');
   *
   * // --pepper
   * program.pepper
   * // => Boolean
   *
   * // simple boolean defaulting to true
   * program.option('-C, --no-cheese', 'remove cheese');
   *
   * program.cheese
   * // => true
   *
   * // --no-cheese
   * program.cheese
   * // => false
   *
   * // required argument
   * program.option('-C, --chdir <path>', 'change the working directory');
   *
   * // --chdir /tmp
   * program.chdir
   * // => "/tmp"
   *
   * // optional argument
   * program.option('-c, --cheese [type]', 'add cheese [marble]');
   * ```
   *
   * @param flags
   * @param description
   * @param fn
   * @param defaultValue
   * @returns [[Command]] for chaining
   */


  option(flags, description, fn, defaultValue) {
    const option = new _option.default(flags, description);
    const optionName = option.name();
    const name = option.attributeName(); // default as 3rd arg

    if (typeof fn !== 'function') {
      if (fn instanceof RegExp) {
        const regex = fn;

        fn = (val, def) => {
          const m = regex.exec(val);
          return m ? m[0] : def;
        };
      } else {
        defaultValue = fn;
      }
    } // preassign default value only for --no-*, [optional], or <required>


    if (!option.bool || option.optional || option.required) {
      // when --no-* we make sure default is true
      if (!option.bool) defaultValue = true; // preassign only if we have a default

      if (defaultValue !== undefined) {
        this[name] = defaultValue;
        option.defaultValue = defaultValue;
      }
    } // register the option


    this.options.push(option); // when it's passed assign the value
    // and conditionally invoke the callback

    this.on(`option:${optionName}`, val => {
      // coercion
      if (val != null && typeof fn === 'function') {
        val = fn(val, this[name] === undefined ? defaultValue : this[name]);
      } // unassigned or bool


      if (typeof this[name] === 'boolean' || typeof this[name] === 'undefined') {
        // if no value, bool true, and we have a default, then use it!
        if (val == null) {
          this[name] = option.bool ? defaultValue || true : false;
        } else {
          this[name] = val;
        }
      } else if (val != null) {
        // reassign
        this[name] = val;
      }
    });
    return this;
  }
  /**
   * Get the value of an option
   *
   * @param name - The name of the option you want to get
   * @returns the value of the requested option
   */


  get(name) {
    if (!(name in this)) {
      throw new Error(`Option "${name}" does not exist`);
    }

    return this[name];
  }
  /**
   * Allow unknown options on the command line.
   *
   * @param arg - if `false`, error will be thrown if unknown option passed. Defaults to `false`
   * for unknown options.
   */


  allowUnknownOption(arg = false) {
    this._allowUnknownOption = arg;
    return this;
  }
  /**
   * Define completion rules which will later be used by autocomplete to generate appropriate response
   *
   * ```js
   * program()
   *   .arguments('<a> <b>')
   *   .option('--verbose', 'verbose')
   *   .option('-n, --name <name>', 'specify name')
   *   .option('--description <desc>', 'specify description')
   *   .complete({
   *     options: {
   *       '--name': (typedArgs) => ['kate', 'jim'],
   *       '--description': ['desc1', 'desc2']
   *     },
   *     arguments: {
   *       a: (typedArgs) => ['a-1', 'a-2'],
   *       b: ['b-1', 'b-2']
   *     }
   *   });
   * ```
   *
   * @param completion - rules
   */


  complete(rules) {
    // merge options
    // this should ensure this._completionRules are always in shape
    if (rules.options) {
      this._completionRules.options = rules.options;
    } // support both arguments or args as key


    if (rules.arguments) {
      this._completionRules.args = rules.arguments;
    } else if (rules.args) {
      this._completionRules.args = rules.args;
    }

    return this;
  }
  /**
   * Test if any complete rules has been defined for current command or its subcommands.
   *
   * @returns if any complete rules has been defined for current command or its subcommands.
   */


  hasCompletionRules() {
    function isEmptyRule({
      options,
      args
    }) {
      return Object.keys(options).length === 0 && Object.keys(args).length === 0;
    }

    return !(isEmptyRule(this._completionRules) && this.commands.every(({
      _completionRules
    }) => isEmptyRule(_completionRules)));
  }
  /**
   * Handle autocomplete if command args starts with special options.
   * It will exit current process after successful processing.
   *
   * @returns [[Command]] from chaining
   */


  autocomplete(argv) {
    const RESERVED_STARTING_KEYWORDS = ['--completion', '--completion-fish', '--compzsh', '--compbash', '--compfish'];
    const firstArg = argv[2];

    if (RESERVED_STARTING_KEYWORDS.includes(firstArg)) {
      // lazy require
      // eslint-disable-next-line @typescript-eslint/no-var-requires
      const omelette = require('omelette');

      const executableName = _path.default.basename(argv[1], '.js');

      const completion = omelette(executableName);
      completion.on('complete', (_f, event) => {
        this.autocompleteHandleEvent(event);
      }); // omelette will call process.exit(0)

      completion.init();
    }

    return this;
  }
  /**
   * Handle omelette complete event
   *
   * @param omelette event which contains fragment, line, reply info
   */


  autocompleteHandleEvent(event) {
    if (this.commands.length > 0) {
      // sub command style
      if (event.fragment === 1) {
        // for sub command first complete should return command
        const commands = this.commands.map(c => c.getName());
        event.reply(commands.concat(['--help']));
      } else {
        const elements = event.line.split(' ');
        const commandName = elements[1];
        const commandArgs = elements.slice(2, event.fragment);
        const currentCommand = this.commands.find(c => c.getName() === commandName);

        if (currentCommand) {
          event.reply(currentCommand.autocompleteCandidates(commandArgs));
        } else {
          event.reply([]);
        }
      }
    } else {
      // single command style
      const singleCommandArgs = event.line.split(' ').slice(1, event.fragment);

      if (event.fragment === 1) {
        // offer --help for the first complete only
        event.reply(this.autocompleteCandidates(singleCommandArgs).concat(['--help']));
      } else {
        event.reply(this.autocompleteCandidates(singleCommandArgs));
      }
    }
  }
  /**
   * Get candidates base on current line input and completionRules.
   * This is the core of smart logic of autocompletion
   *
   * @param typed args
   * @returns auto complete candidates
   */


  autocompleteCandidates(typedArgs) {
    const completionRules = this.autocompleteNormalizeRules();
    const activeOption = autocompleteActiveOption(completionRules.options, typedArgs);

    if (activeOption) {
      // if current typedArgs suggests it's filling an option
      // next value would be the possible values for that option
      const {
        reply
      } = activeOption;

      if (typeof reply === 'function') {
        return reply(typedArgs) || [];
      }

      if (Array.isArray(reply)) {
        return reply;
      }

      return [];
    } // otherwise
    // next value would be one of the unused option names


    const optionNames = Object.keys(completionRules.options).filter(name => {
      const option = completionRules.options[name];

      if (option.sibling) {
        // remove both option and its sibling form
        return !typedArgs.includes(name) && !typedArgs.includes(option.sibling);
      }

      return !typedArgs.includes(name);
    }); // or possible values for next arguments

    const activeArg = autocompleteActiveArg(completionRules.options, completionRules.args, typedArgs);

    if (typeof activeArg === 'function') {
      return optionNames.concat(activeArg(typedArgs) || []);
    }

    if (Array.isArray(activeArg)) {
      return optionNames.concat(activeArg);
    }

    return optionNames;
  }
  /**
   * For the ease of processing,
   * the internal presentation of completion rules is quite different from user input.
   *
   * @returns normalized rules
   */


  autocompleteNormalizeRules() {
    // supplement with important information including
    // option arity and sibling
    const rawRules = this._completionRules;
    const {
      options
    } = this;
    const args = this._args;
    const normalizedRules = {
      options: {},
      args: []
    };
    options.forEach(option => {
      if (option.short) {
        const reply = rawRules.options[option.long] || rawRules.options[option.short] || [];
        normalizedRules.options[option.short] = {
          arity: option.arity(),
          sibling: option.long,
          reply
        };
        normalizedRules.options[option.long] = {
          arity: option.arity(),
          sibling: option.short,
          reply
        };
      } else {
        normalizedRules.options[option.long] = {
          arity: option.arity(),
          sibling: null,
          reply: rawRules.options[option.long] || []
        };
      }
    });
    args.forEach(({
      name
    }) => {
      normalizedRules.args.push(rawRules.args[name] || []);
    });
    return normalizedRules;
  }
  /**
   * Parse `argv`, settings options and invoking commands when defined.
   *
   * @param argv
   * @returns [[Command]] for chaining
   */


  parse(argv) {
    // trigger autocomplete first if some completion rules have been defined
    if (this.hasCompletionRules()) {
      this.autocomplete(argv);
    } // implicit help


    if (this.executables) this.addImplicitHelpCommand(); // store raw args

    this.rawArgs = argv; // guess name

    this._name = this._name || _path.default.basename(argv[1], '.js'); // github-style sub-commands with no sub-command

    if (this.executables && argv.length < 3 && !this.defaultExecutable) {
      // this user needs help
      argv.push('--help');
    } // process argv


    const parsed = this.parseOptions(this.normalize(argv.slice(2)));
    const args = this.args = parsed.args;
    const result = this.parseArgs(this.args, parsed.unknown); // executable sub-commands

    const name = result.args[0];
    let aliasCommand = null; // check alias of sub commands

    if (name) {
      aliasCommand = this.commands.filter(command => command.getAlias() === name)[0];
    }

    if (this.execs[name] && typeof this.execs[name] !== 'function') {
      this.executeSubCommand(argv, args, parsed.unknown);
      return this;
    }

    if (aliasCommand && typeof aliasCommand._name === 'string') {
      // is alias of a subCommand
      args[0] = aliasCommand._name;
      this.executeSubCommand(argv, args, parsed.unknown);
      return this;
    }

    if (this.defaultExecutable) {
      // use the default subcommand
      args.unshift(this.defaultExecutable);
      this.executeSubCommand(argv, args, parsed.unknown);
      return this;
    } // Output unknown command error


    if (args.length > 0) {
      console.error('error: unknown command %s', args[0]);
      this.outputHelp();
    }

    return result;
  }
  /**
   * Execute a sub-command executable.
   *
   * @param argv
   * @param args
   * @param unknown
   */


  executeSubCommand(argv, args, unknown) {
    args = args.concat(unknown);
    if (!args.length) this.help();
    if (args[0] === 'help' && args.length === 1) this.help(); // <cmd> --help

    if (args[0] === 'help') {
      args[0] = args[1];
      args[1] = '--help';
    } // executable


    const f = argv[1]; // name of the subcommand, link `pm-install`

    let bin = `${_path.default.basename(f, _path.default.extname(f))}-${args[0]}`; // In case of globally installed, get the base dir where executable
    //  subcommand file should be located at

    let link = _fs.default.lstatSync(f).isSymbolicLink() ? _fs.default.readlinkSync(f) : f; // when symbolink is relative path

    if (link !== f && link.charAt(0) !== '/') {
      link = _path.default.join(_path.default.dirname(f), link);
    }

    const baseDir = _path.default.dirname(link); // prefer local `./<bin>` to bin in the $PATH


    const localBin = _path.default.join(baseDir, bin); // whether bin file is a js script with explicit `.js` or `.ts` extension


    let isExplicitJS = false;

    if (_fs.default.existsSync(`${localBin}.js`)) {
      bin = `${localBin}.js`;
      isExplicitJS = true;
    } else if (_fs.default.existsSync(`${localBin}.ts`)) {
      bin = `${localBin}.ts`;
      isExplicitJS = true;
    } else if (_fs.default.existsSync(localBin)) {
      bin = localBin;
    }

    args = args.slice(1);
    let proc;

    if (process.platform !== 'win32') {
      if (isExplicitJS) {
        args.unshift(bin); // add executable arguments to spawn

        args = (process.execArgv || []).concat(args);
        proc = (0, _child_process.spawn)(process.argv[0], args, {
          stdio: 'inherit'
        });
      } else {
        proc = (0, _child_process.spawn)(bin, args, {
          stdio: 'inherit'
        });
      }
    } else {
      args.unshift(bin);
      proc = (0, _child_process.spawn)(process.execPath, args, {
        stdio: 'inherit'
      });
    }

    const signals = ['SIGUSR1', 'SIGUSR2', 'SIGTERM', 'SIGINT', 'SIGHUP'];
    signals.forEach(signal => {
      process.on(signal, () => {
        // @ts-ignore
        if (proc.killed === false && proc.exitCode == null) {
          proc.kill(signal);
        }
      });
    });
    proc.on('close', process.exit.bind(process));
    proc.on('error', ({
      code
    }) => {
      if (code === 'ENOENT') {
        console.error('error: %s(1) does not exist, try --help', bin);
      } else if (code === 'EACCES') {
        console.error('error: %s(1) not executable. try chmod or run with root', bin);
      }

      process.exit(1);
    }); // Store the reference to the child process

    this.runningCommand = proc;
  }
  /**
   * Normalize `args`, splitting joined short flags. For example
   * the arg "-abc" is equivalent to "-a -b -c".
   * This also normalizes equal sign and splits "--abc=def" into "--abc def".
   *
   * @param args
   * @returns array of normalized `args`
   */


  normalize(args) {
    let ret = [];
    let arg;
    let lastOpt;
    let index;

    for (let i = 0, len = args.length; i < len; ++i) {
      arg = args[i];

      if (i > 0) {
        lastOpt = this.optionFor(args[i - 1]);
      }

      if (arg === '--') {
        // Honor option terminator
        ret = ret.concat(args.slice(i));
        break;
      } else if (lastOpt && lastOpt.required) {
        ret.push(arg);
      } else if (arg.length > 1 && arg[0] === '-' && arg[1] !== '-') {
        arg.slice(1).split('').forEach(c => {
          ret.push(`-${c}`);
        });
      } else if (/^--/.test(arg) && ~(index = arg.indexOf('='))) {
        ret.push(arg.slice(0, index), arg.slice(index + 1));
      } else {
        ret.push(arg);
      }
    }

    return ret;
  }
  /**
   * Parse command `args`.
   *
   * When listener(s) are available those
   * callbacks are invoked, otherwise the "*"
   * event is emitted and those actions are invoked.
   *
   * @param args
   * @returns [[Command]] for chaining
   */


  parseArgs(args, unknown) {
    let name;

    if (args.length) {
      name = args[0];

      if (this.listeners(`command:${name}`).length) {
        this.emit(`command:${args.shift()}`, args, unknown);
      } else {
        this.emit('command:*', args);
      }
    } else {
      outputHelpIfNecessary(this, unknown); // If there were no args and we have unknown options,
      // then they are extraneous and we need to error.

      if (unknown.length > 0) {
        this.unknownOption(unknown[0]);
      }

      if (this.commands.length === 0 && this._args.filter(({
        required
      }) => required).length === 0) {
        this.emit('command:*');
      }
    }

    return this;
  }
  /**
   * Get an [[Option]] matching `arg` if any.
   *
   * @param arg
   * @returns an [[Option]] matching `arg` if any.
   */


  optionFor(arg) {
    const option = this.options.find(option => option.is(arg));
    return option;
  }
  /**
   * Parse options from `argv` returning `argv` void of these options.
   *
   * @param argv
   * @returns {Array}
   */


  parseOptions(argv) {
    const args = [];
    const len = argv.length;
    let literal;
    let option;
    let arg;
    const unknownOptions = []; // parse options

    for (let i = 0; i < len; ++i) {
      arg = argv[i]; // literal args after --

      if (literal) {
        args.push(arg);
        continue;
      }

      if (arg === '--') {
        literal = true;
        continue;
      } // find matching Option


      option = this.optionFor(arg); // option is defined

      if (option) {
        // requires arg
        if (option.required) {
          arg = argv[++i];

          if (arg == null) {
            this.optionMissingArgument(option);
            return {
              args: [],
              unknown: []
            };
          }

          this.emit(`option:${option.name()}`, arg); // optional arg
        } else if (option.optional) {
          arg = argv[i + 1]; // no arg provided

          if (arg == null || arg && arg[0] === '-' && arg !== '-') {
            arg = null;
          } else {
            ++i;
          }

          this.emit(`option:${option.name()}`, arg); // bool
        } else {
          this.emit(`option:${option.name()}`);
        }

        continue;
      } // looks like an option


      if (arg.length > 1 && arg[0] === '-') {
        unknownOptions.push(arg); // If the next argument looks like it might be
        // an argument for this option, we pass it on.
        // If it isn't, then it'll simply be ignored

        if (i + 1 < argv.length && argv[i + 1][0] !== '-') {
          unknownOptions.push(argv[++i]);
        }

        continue;
      } // arg


      args.push(arg);
    }

    return {
      args,
      unknown: unknownOptions
    };
  }
  /**
   * Get an object containing options as key-value pairs
   *
   * @returns an object containing options as key-value pairs
   */


  opts() {
    const result = {};
    const len = this.options.length;

    for (let i = 0; i < len; i++) {
      const key = this.options[i].attributeName();
      result[key] = key === this.versionOptionName ? this._version : this[key];
    }

    return result;
  }
  /**
   * Log error when rgument `name` is missing.
   *
   * @param name
   */


  missingArgument(name) {
    console.error('error: missing required argument `%s`', name);
    process.exit(1);
  }
  /**
   * Log error when [[Option]] is missing an argument, but received `flag` or nothing.
   *
   * @param option
   * @param flag
   */


  optionMissingArgument({
    flags
  }, flag) {
    if (flag) {
      console.error('error: option `%s` argument missing, got `%s`', flags, flag);
    } else {
      console.error('error: option `%s` argument missing', flags);
    }

    process.exit(1);
  }
  /**
   * Log error when received unknown option `flag`
   *
   * @param flag
   */


  unknownOption(flag) {
    if (this._allowUnknownOption) return;
    console.error('error: unknown option `%s`', flag);
    process.exit(1);
  }
  /**
   * Variadic argument with `name` is not the last argument as required.
   *
   * @param name
   */


  variadicArgNotLast(name) {
    console.error('error: variadic arguments must be last `%s`', name);
    process.exit(1);
  }
  /**
   * Set the program version
   *
   * This method auto-registers the "-V, --version" flag
   * which will print the version number when passed.
   *
   * @param version
   * @param [flags]
   * @returns [[Command]] for chaining
   */


  version(version, flags) {
    this._version = version;
    flags = flags || '-V, --version';
    const versionOption = new _option.default(flags, 'output the version number');
    this.versionOptionName = versionOption.long.substr(2) || 'version';
    this.options.push(versionOption);
    this.on(`option:${this.versionOptionName}`, () => {
      process.stdout.write(`${version}\n`);
      process.exit(0);
    });
    return this;
  }
  /**
   * Set the command description
   *
   * @param str - the description for the command
   * @param argsDescription
   * @returns [[Command]] for chaining
   */


  description(str, argsDescription) {
    this._description = str;
    this.argsDescription = argsDescription;
    return this;
  }
  /**
   * Set an alias for the command
   *
   * @param alias - what to alias the command to
   * @returns [[Command]] for chaining
   */


  alias(alias) {
    let command = this;

    if (this.commands.length !== 0) {
      command = this.commands[this.commands.length - 1];
    }

    if (alias === command._name) {
      throw new Error("Command alias can't be the same as its name");
    }

    if (alias) {
      command._alias = alias;
    }

    return this;
  }
  /**
   * Get the alias for the command
   *
   * @param alias - what to alias the command to
   * @returns the alias
   */


  getAlias() {
    let command = this;

    if (this.commands.length !== 0) {
      command = this.commands[this.commands.length - 1];
    }

    return command._alias;
  }
  /**
   * Set the command usage
   *
   * @param str
   * @returns [[Command]] for chaining
   */


  usage(usage) {
    this._usage = usage;
    return this;
  }
  /**
   * Get the usage prompt as a string
   */


  getUsage() {
    const args = this._args.map(arg => humanReadableArgName(arg));

    const usage = `[options]${this.commands.length ? ' [command]' : ''}${this._args.length ? ` ${args.join(' ')}` : ''}`;
    return this._usage || usage;
  }
  /**
   * Set the name of the command
   *
   * @param str
   * @returns [[Command]] for chaining
   */


  name(str) {
    this._name = str;
    return this;
  }
  /**
   * Get the name of the command
   *
   * @param str
   * @returns the name of the command
   */


  getName() {
    return this._name || '';
  }
  /**
   * Get prepared commands.
   *
   * @returns prepared commands
   */


  prepareCommands() {
    return this.commands.filter(({
      noHelp
    }) => !noHelp).map(cmd => {
      const args = cmd._args.map(arg => humanReadableArgName(arg)).join(' ');

      return [cmd._name + (cmd._alias ? `|${cmd._alias}` : '') + (cmd.options.length ? ' [options]' : '') + (args ? ` ${args}` : ''), cmd._description];
    });
  }
  /**
   * Get the largest command length.
   *
   * @returns the largest command length
   */


  largestCommandLength() {
    const commands = this.prepareCommands();
    return commands.reduce((max, command) => Math.max(max, command[0].length), 0);
  }
  /**
   * Get the largest option length.
   *
   * @returns the largest option length
   */


  largestOptionLength() {
    const options = [].slice.call(this.options);
    options.push({
      flags: '-h, --help'
    });
    return options.reduce((max, {
      flags
    }) => Math.max(max, flags.length), 0);
  }
  /**
   * Get the largest arg length.
   *
   * @returns the largest arg length
   */


  largestArgLength() {
    return this._args.reduce((max, {
      name
    }) => Math.max(max, name.length), 0);
  }
  /**
   * Get the pad width.
   *
   * @returns the pad width
   */


  padWidth() {
    let width = this.largestOptionLength();

    if (this.argsDescription && this._args.length) {
      if (this.largestArgLength() > width) {
        width = this.largestArgLength();
      }
    }

    if (this.commands && this.commands.length) {
      if (this.largestCommandLength() > width) {
        width = this.largestCommandLength();
      }
    }

    return width;
  }
  /**
   * Get help for options.
   *
   * @returns help options as a string
   */


  optionHelp() {
    const width = this.padWidth(); // Append the help information

    return this.options.map(({
      flags,
      description,
      bool,
      defaultValue
    }) => `${pad(flags, width)}  ${description}${bool && defaultValue !== undefined ? ` (default: ${JSON.stringify(defaultValue)})` : ''}`).concat([`${`${pad('-h, --help', width)}  `}output usage information`]).join('\n');
  }
  /**
   * Get command help documentation.
   *
   * @returns command help documentation
   */


  commandHelp() {
    if (!this.commands.length) return '';
    const commands = this.prepareCommands();
    const width = this.padWidth();
    return ['Commands:', commands.map(cmd => {
      const desc = cmd[1] ? `  ${cmd[1]}` : '';
      return (desc ? pad(cmd[0], width) : cmd[0]) + desc;
    }).join('\n').replace(/^/gm, '  '), ''].join('\n');
  }
  /**
   * Get program help documentation.
   *
   * @returns program help documentation
   */


  helpInformation() {
    let desc = [];

    if (this._description) {
      desc = [this._description, ''];
      const {
        argsDescription
      } = this;

      if (argsDescription && this._args.length) {
        const width = this.padWidth();
        desc.push('Arguments:');
        desc.push('');

        this._args.forEach(({
          name
        }) => {
          desc.push(`  ${pad(name, width)}  ${argsDescription[name]}`);
        });

        desc.push('');
      }
    }

    let cmdName = this._name;

    if (this._alias) {
      cmdName = `${cmdName}|${this._alias}`;
    }

    const usage = [`Usage: ${cmdName} ${this.getUsage()}`, ''];
    let cmds = [];
    const commandHelp = this.commandHelp();
    if (commandHelp) cmds = [commandHelp];
    const options = ['Options:', `${this.optionHelp().replace(/^/gm, '  ')}`, ''];
    return usage.concat(desc).concat(options).concat(cmds).join('\n');
  }
  /**
   * Output help information for this command
   */


  outputHelp(cb) {
    if (!cb) {
      cb = passthru => passthru;
    }

    process.stdout.write(cb(this.helpInformation()));
    this.emit('--help');
  }
  /**
   * Output help information and exit.
   */


  help(cb) {
    this.outputHelp(cb);
    process.exit(1);
  }

}
/**
 * Expose the root command.
 */


exports.Command = Command;

function CommandFactory(name) {
  return new Command(name);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9jb21tYW5kLnRzIl0sIm5hbWVzIjpbInBhZCIsInN0ciIsIndpZHRoIiwibGVuIiwiTWF0aCIsIm1heCIsImxlbmd0aCIsIkFycmF5Iiwiam9pbiIsIm91dHB1dEhlbHBJZk5lY2Vzc2FyeSIsImNtZCIsIm9wdGlvbnMiLCJpIiwib3V0cHV0SGVscCIsInByb2Nlc3MiLCJleGl0IiwiaHVtYW5SZWFkYWJsZUFyZ05hbWUiLCJuYW1lIiwidmFyaWFkaWMiLCJyZXF1aXJlZCIsIm5hbWVPdXRwdXQiLCJhdXRvY29tcGxldGVBY3RpdmVPcHRpb24iLCJvcHRpb25SdWxlcyIsInR5cGVkQXJncyIsImxhc3RBcmciLCJvcHRpb24iLCJhcml0eSIsImF1dG9jb21wbGV0ZUFjdGl2ZUFyZyIsImFyZ1J1bGVzIiwiY291bnQiLCJjdXJyIiwiY3VyclN0ciIsIkNvbW1hbmQiLCJFdmVudEVtaXR0ZXIiLCJjb25zdHJ1Y3RvciIsImFyZ3MiLCJfbmFtZSIsImNvbW1hbmQiLCJkZXNjIiwib3B0cyIsImlzRGVmYXVsdCIsIm5vSGVscCIsInNwbGl0Iiwic2hpZnQiLCJkZXNjcmlwdGlvbiIsImV4ZWN1dGFibGVzIiwiZXhlY3MiLCJkZWZhdWx0RXhlY3V0YWJsZSIsImNvbW1hbmRzIiwicHVzaCIsInBhcnNlRXhwZWN0ZWRBcmdzIiwicGFyZW50IiwiYXJndW1lbnRzIiwiYWRkSW1wbGljaXRIZWxwQ29tbWFuZCIsImZvckVhY2giLCJhcmciLCJhcmdEZXRhaWxzIiwic2xpY2UiLCJfYXJncyIsImFjdGlvbiIsImZuIiwibGlzdGVuZXIiLCJ1bmtub3duIiwicGFyc2VkIiwicGFyc2VPcHRpb25zIiwidW5rbm93bk9wdGlvbiIsImNvbmNhdCIsIm1pc3NpbmdBcmd1bWVudCIsInZhcmlhZGljQXJnTm90TGFzdCIsInNwbGljZSIsImFwcGx5Iiwib24iLCJfYWxpYXMiLCJmbGFncyIsImRlZmF1bHRWYWx1ZSIsIk9wdGlvbiIsIm9wdGlvbk5hbWUiLCJhdHRyaWJ1dGVOYW1lIiwiUmVnRXhwIiwicmVnZXgiLCJ2YWwiLCJkZWYiLCJtIiwiZXhlYyIsImJvb2wiLCJvcHRpb25hbCIsInVuZGVmaW5lZCIsImdldCIsIkVycm9yIiwiYWxsb3dVbmtub3duT3B0aW9uIiwiX2FsbG93VW5rbm93bk9wdGlvbiIsImNvbXBsZXRlIiwicnVsZXMiLCJfY29tcGxldGlvblJ1bGVzIiwiaGFzQ29tcGxldGlvblJ1bGVzIiwiaXNFbXB0eVJ1bGUiLCJPYmplY3QiLCJrZXlzIiwiZXZlcnkiLCJhdXRvY29tcGxldGUiLCJhcmd2IiwiUkVTRVJWRURfU1RBUlRJTkdfS0VZV09SRFMiLCJmaXJzdEFyZyIsImluY2x1ZGVzIiwib21lbGV0dGUiLCJyZXF1aXJlIiwiZXhlY3V0YWJsZU5hbWUiLCJwYXRoIiwiYmFzZW5hbWUiLCJjb21wbGV0aW9uIiwiX2YiLCJldmVudCIsImF1dG9jb21wbGV0ZUhhbmRsZUV2ZW50IiwiaW5pdCIsImZyYWdtZW50IiwibWFwIiwiYyIsImdldE5hbWUiLCJyZXBseSIsImVsZW1lbnRzIiwibGluZSIsImNvbW1hbmROYW1lIiwiY29tbWFuZEFyZ3MiLCJjdXJyZW50Q29tbWFuZCIsImZpbmQiLCJhdXRvY29tcGxldGVDYW5kaWRhdGVzIiwic2luZ2xlQ29tbWFuZEFyZ3MiLCJjb21wbGV0aW9uUnVsZXMiLCJhdXRvY29tcGxldGVOb3JtYWxpemVSdWxlcyIsImFjdGl2ZU9wdGlvbiIsImlzQXJyYXkiLCJvcHRpb25OYW1lcyIsImZpbHRlciIsInNpYmxpbmciLCJhY3RpdmVBcmciLCJyYXdSdWxlcyIsIm5vcm1hbGl6ZWRSdWxlcyIsInNob3J0IiwibG9uZyIsInBhcnNlIiwicmF3QXJncyIsIm5vcm1hbGl6ZSIsInJlc3VsdCIsInBhcnNlQXJncyIsImFsaWFzQ29tbWFuZCIsImdldEFsaWFzIiwiZXhlY3V0ZVN1YkNvbW1hbmQiLCJ1bnNoaWZ0IiwiY29uc29sZSIsImVycm9yIiwiaGVscCIsImYiLCJiaW4iLCJleHRuYW1lIiwibGluayIsImZzIiwibHN0YXRTeW5jIiwiaXNTeW1ib2xpY0xpbmsiLCJyZWFkbGlua1N5bmMiLCJjaGFyQXQiLCJkaXJuYW1lIiwiYmFzZURpciIsImxvY2FsQmluIiwiaXNFeHBsaWNpdEpTIiwiZXhpc3RzU3luYyIsInByb2MiLCJwbGF0Zm9ybSIsImV4ZWNBcmd2Iiwic3RkaW8iLCJleGVjUGF0aCIsInNpZ25hbHMiLCJzaWduYWwiLCJraWxsZWQiLCJleGl0Q29kZSIsImtpbGwiLCJiaW5kIiwiY29kZSIsInJ1bm5pbmdDb21tYW5kIiwicmV0IiwibGFzdE9wdCIsImluZGV4Iiwib3B0aW9uRm9yIiwidGVzdCIsImluZGV4T2YiLCJsaXN0ZW5lcnMiLCJlbWl0IiwiaXMiLCJsaXRlcmFsIiwidW5rbm93bk9wdGlvbnMiLCJvcHRpb25NaXNzaW5nQXJndW1lbnQiLCJrZXkiLCJ2ZXJzaW9uT3B0aW9uTmFtZSIsIl92ZXJzaW9uIiwiZmxhZyIsInZlcnNpb24iLCJ2ZXJzaW9uT3B0aW9uIiwic3Vic3RyIiwic3Rkb3V0Iiwid3JpdGUiLCJhcmdzRGVzY3JpcHRpb24iLCJfZGVzY3JpcHRpb24iLCJhbGlhcyIsInVzYWdlIiwiX3VzYWdlIiwiZ2V0VXNhZ2UiLCJwcmVwYXJlQ29tbWFuZHMiLCJsYXJnZXN0Q29tbWFuZExlbmd0aCIsInJlZHVjZSIsImxhcmdlc3RPcHRpb25MZW5ndGgiLCJjYWxsIiwibGFyZ2VzdEFyZ0xlbmd0aCIsInBhZFdpZHRoIiwib3B0aW9uSGVscCIsIkpTT04iLCJzdHJpbmdpZnkiLCJjb21tYW5kSGVscCIsInJlcGxhY2UiLCJoZWxwSW5mb3JtYXRpb24iLCJjbWROYW1lIiwiY21kcyIsImNiIiwicGFzc3RocnUiLCJDb21tYW5kRmFjdG9yeSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7Ozs7O0FBcUJBOzs7Ozs7O0FBT0EsU0FBU0EsR0FBVCxDQUFhQyxHQUFiLEVBQTBCQyxLQUExQixFQUFpRDtBQUMvQyxRQUFNQyxHQUFHLEdBQUdD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Q0FBd0I3TSxJQUF4QixFQUF1QztBQUNwRCxTQUFPLElBQUllLE9BQUosQ0FBWWYsSUFBWixDQUFQO0FBQ0QiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICdldmVudHMnO1xuaW1wb3J0IHsgc3Bhd24sIENoaWxkUHJvY2VzcyB9IGZyb20gJ2NoaWxkX3Byb2Nlc3MnO1xuaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgZnMgZnJvbSAnZnMnO1xuaW1wb3J0IE9wdGlvbiBmcm9tICcuL29wdGlvbic7XG5cbmV4cG9ydCBpbnRlcmZhY2UgQXV0b2NvbXBsZXRlRXZlbnQge1xuICBmcmFnbWVudDogbnVtYmVyO1xuICBsaW5lOiBzdHJpbmc7XG4gIHJlcGx5OiAoY29tbWFuZHM6IHN0cmluZ1tdKSA9PiB2b2lkO1xufVxuXG5leHBvcnQgdHlwZSBBcmdzID0gc3RyaW5nW107XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29tcGxldGlvbkFyZ3Mge1xuICBmaWxlbmFtZTogc3RyaW5nW107XG4gIGFyZ3M6IHN0cmluZ1tdO1xuICB1cmw6IHN0cmluZ1tdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENvbXBsZXRpb25SdWxlcyB7XG4gIGFyZ3M6IENvbXBsZXRpb25BcmdzIHwgQXJncztcbiAgb3B0aW9uczogUmVjb3JkPHN0cmluZywgQXJncyB8IEZ1bmN0aW9uPjtcbn1cblxuLyoqXG4gKiBQYWQgYHN0cmAgdG8gYHdpZHRoYC5cbiAqXG4gKiBAcGFyYW0gc3RyXG4gKiBAcGFyYW0gd2lkdGhcbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uIHBhZChzdHI6IHN0cmluZywgd2lkdGg6IG51bWJlcik6IHN0cmluZyB7XG4gIGNvbnN0IGxlbiA9IE1hdGgubWF4KDAsIHdpZHRoIC0gc3RyLmxlbmd0aCk7XG4gIHJldHVybiBzdHIgKyBBcnJheShsZW4gKyAxKS5qb2luKCcgJyk7XG59XG5cbi8qKlxuICogT3V0cHV0IGhlbHAgaW5mb3JtYXRpb24gaWYgbmVjZXNzYXJ5XG4gKlxuICogQHBhcmFtIGNvbW1hbmQgLSB0aGUgY29tbWFuZCB0byBvdXRwdXQgaGVscCBmb3JcbiAqIEBwYXJhbSBvcHRpb25zIC0gYW4gYXJyYXkgb2Ygb3B0aW9ucyB0byBzZWFyY2ggZm9yIGAtaGAgb3IgYC0taGVscGBcbiAqL1xuZnVuY3Rpb24gb3V0cHV0SGVscElmTmVjZXNzYXJ5KGNtZDogQ29tbWFuZCwgb3B0aW9uczogc3RyaW5nW10gPSBbXSkge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG9wdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAob3B0aW9uc1tpXSA9PT0gJy0taGVscCcgfHwgb3B0aW9uc1tpXSA9PT0gJy1oJykge1xuICAgICAgY21kLm91dHB1dEhlbHAoKTtcbiAgICAgIHByb2Nlc3MuZXhpdCgwKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBUYWtlcyBhbiBhcmd1bWVudCBhbiByZXR1cm5zIGl0cyBodW1hbiByZWFkYWJsZSBlcXVpdmFsZW50IGZvciBoZWxwIHVzYWdlLlxuICpcbiAqIEBwYXJhbSBhcmdcbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uIGh1bWFuUmVhZGFibGVBcmdOYW1lKHtcbiAgbmFtZSxcbiAgdmFyaWFkaWMsXG4gIHJlcXVpcmVkXG59OiB7XG4gIG5hbWU6IHN0cmluZztcbiAgdmFyaWFkaWM6IGJvb2xlYW47XG4gIHJlcXVpcmVkOiBib29sZWFuO1xufSk6IHN0cmluZyB7XG4gIGNvbnN0IG5hbWVPdXRwdXQgPSBuYW1lICsgKHZhcmlhZGljID09PSB0cnVlID8gJy4uLicgOiAnJyk7XG5cbiAgcmV0dXJuIHJlcXVpcmVkID8gYDwke25hbWVPdXRwdXR9PmAgOiBgWyR7bmFtZU91dHB1dH1dYDtcbn1cblxuLyoqXG4gKiBEZXRlY3Qgd2hldGhlciBjdXJyZW50IGNvbW1hbmQgbGluZSBpbnB1dCBpbmZlcnMgYW4gb3B0aW9uLlxuICpcbiAqIEBwYXJhbSBub3JtYWxpemVkIG9wdGlvbiBydWxlc1xuICogQHBhcmFtIHR5cGVkIGFyZ3NcbiAqIEByZXR1cm5zIGFjdGl2ZSBvcHRpb24gaWYgZm91bmQsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBhdXRvY29tcGxldGVBY3RpdmVPcHRpb24oXG4gIG9wdGlvblJ1bGVzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+LFxuICB0eXBlZEFyZ3M6IHN0cmluZ1tdXG4pOiBmYWxzZSB8IHsgcmVwbHk6IFJlY29yZDxzdHJpbmcsIGFueT4gfSB7XG4gIGlmICh0eXBlZEFyZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY29uc3QgbGFzdEFyZyA9IHR5cGVkQXJnc1t0eXBlZEFyZ3MubGVuZ3RoIC0gMV07XG5cbiAgaWYgKCFvcHRpb25SdWxlc1tsYXN0QXJnXSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNvbnN0IG9wdGlvbiA9IG9wdGlvblJ1bGVzW2xhc3RBcmddO1xuXG4gIGlmIChvcHRpb24uYXJpdHkgPT09IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gb3B0aW9uO1xufVxuXG4vKipcbiAqIERldGVjdCB3aGV0aGVyIGN1cnJlbnQgY29tbWFuZCBsaW5lIGlucHV0IGluZmVycyBhbiBhcmcuXG4gKlxuICogQHBhcmFtIG5vcm1hbGl6ZWQgb3B0aW9uIHJ1bGVzXG4gKiBAcGFyYW0gbm9ybWFsaXplZCBhcmcgcnVsZXNcbiAqIEBwYXJhbSB0eXBlZCBhcmdzXG4gKiBAcmV0dXJucyBhY3RpdmUgYXJnIGlmIGZvdW5kLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gYXV0b2NvbXBsZXRlQWN0aXZlQXJnKFxuICBvcHRpb25SdWxlczogUmVjb3JkPHN0cmluZywgYW55PixcbiAgYXJnUnVsZXM6IEFyZ3MgfCBGdW5jdGlvbltdLFxuICB0eXBlZEFyZ3M6IHN0cmluZ1tdXG4pOiBzdHJpbmcgfCBGdW5jdGlvbiB8IGJvb2xlYW4ge1xuICBpZiAoYXJnUnVsZXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gZmluZCBvdXQgaG93IG1hbnkgYXJncyBoYXZlIGFscmVhZHkgYmVlbiB0eXBlZFxuICBsZXQgY291bnQgPSAwO1xuICBsZXQgY3VyciA9IDA7XG5cbiAgd2hpbGUgKGN1cnIgPCB0eXBlZEFyZ3MubGVuZ3RoKSB7XG4gICAgY29uc3QgY3VyclN0ciA9IHR5cGVkQXJnc1tjdXJyXTtcblxuICAgIGlmIChvcHRpb25SdWxlc1tjdXJyU3RyXSkge1xuICAgICAgY3VyciArPSBvcHRpb25SdWxlc1tjdXJyU3RyXS5hcml0eSArIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvdW50ICs9IDE7XG4gICAgICBjdXJyICs9IDE7XG4gICAgfVxuICB9XG5cbiAgaWYgKGFyZ1J1bGVzLmxlbmd0aCA+IGNvdW50KSB7XG4gICAgcmV0dXJuIGFyZ1J1bGVzW2NvdW50XTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQSBjb21tYW5kIGJ1aWxkZXJcbiAqIEBub0luaGVyaXREb2NcbiAqL1xuZXhwb3J0IGNsYXNzIENvbW1hbmQgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBwdWJsaWMgY29tbWFuZHM6IENvbW1hbmRbXSA9IFtdO1xuXG4gIHByaXZhdGUgb3B0aW9uczogT3B0aW9uW10gPSBbXTtcblxuICBwcml2YXRlIGV4ZWN1dGFibGVzOiBib29sZWFuO1xuXG4gIHByaXZhdGUgZGVmYXVsdEV4ZWN1dGFibGU6IHN0cmluZztcblxuICBwcml2YXRlIHBhcmVudDogQ29tbWFuZDtcblxuICBwcml2YXRlIGFyZ3M6IHN0cmluZ1tdO1xuXG4gIC8qKlxuICAgKiBUaGUgcnVubmluZyBub2RlIHByb2Nlc3MgZnJvbSBydW5uaW5nIGEgc3ViY29tbWFuZCBleGVjdXRhYmxlXG4gICAqL1xuICBwdWJsaWMgcnVubmluZ0NvbW1hbmQ6IENoaWxkUHJvY2VzcztcblxuICBwdWJsaWMgcmF3QXJnczogQXJncztcblxuICBwcml2YXRlIG5vSGVscDogYm9vbGVhbjtcblxuICBwcml2YXRlIGV4ZWNzOiBSZWNvcmQ8c3RyaW5nLCBib29sZWFuPiA9IHt9O1xuXG4gIHByaXZhdGUgYXJnc0Rlc2NyaXB0aW9uOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkO1xuXG4gIHByaXZhdGUgX2FsaWFzOiBzdHJpbmc7XG5cbiAgcHJpdmF0ZSBfYWxsb3dVbmtub3duT3B0aW9uOiBib29sZWFuID0gZmFsc2U7XG5cbiAgcHJpdmF0ZSBfYXJnczogeyByZXF1aXJlZDogYm9vbGVhbjsgbmFtZTogc3RyaW5nOyB2YXJpYWRpYzogYm9vbGVhbiB9W10gPSBbXTtcblxuICBwcml2YXRlIF92ZXJzaW9uOiBzdHJpbmc7XG5cbiAgcHJpdmF0ZSBfZGVzY3JpcHRpb246IHN0cmluZztcblxuICBwcml2YXRlIF91c2FnZTogc3RyaW5nO1xuXG4gIHByaXZhdGUgX25hbWU6IHN0cmluZyB8IHVuZGVmaW5lZDtcblxuICBwcml2YXRlIHZlcnNpb25PcHRpb25OYW1lOiBzdHJpbmc7XG5cbiAgcHJpdmF0ZSBfY29tcGxldGlvblJ1bGVzOiBDb21wbGV0aW9uUnVsZXMgPSB7XG4gICAgb3B0aW9uczoge30sXG4gICAgYXJnczogW11cbiAgfTtcblxuICBwdWJsaWMgY29uc3RydWN0b3IobmFtZTogc3RyaW5nID0gJycpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX25hbWUgPSBuYW1lO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBjb21tYW5kIGBuYW1lYC5cbiAgICpcbiAgICogVGhlIFtbYWN0aW9uXV0gY2FsbGJhY2sgaXMgaW52b2tlZCB3aGVuIHRoZVxuICAgKiBjb21tYW5kIGBuYW1lYCBpcyBzcGVjaWZpZWQgdmlhIF9fQVJHVl9fLFxuICAgKiBhbmQgdGhlIHJlbWFpbmluZyBhcmd1bWVudHMgYXJlIGFwcGxpZWQgdG8gdGhlXG4gICAqIGZ1bmN0aW9uIGZvciBhY2Nlc3MuXG4gICAqXG4gICAqIFdoZW4gdGhlIGBuYW1lYCBpcyBcIipcIiBhbiB1bi1tYXRjaGVkIGNvbW1hbmRcbiAgICogd2lsbCBiZSBwYXNzZWQgYXMgdGhlIGZpcnN0IGFyZywgZm9sbG93ZWQgYnlcbiAgICogdGhlIHJlc3Qgb2YgX19BUkdWX18gcmVtYWluaW5nLlxuICAgKlxuICAgKiBFeGFtcGxlczpcbiAgICogYGBgdHNcbiAgICogY29uc3QgcHJvZyA9IHByb2dyYW0oKVxuICAgKiAgIC52ZXJzaW9uKCcwLjAuMScpXG4gICAqICAgLm9wdGlvbignLUMsIC0tY2hkaXIgPHBhdGg+JywgJ2NoYW5nZSB0aGUgd29ya2luZyBkaXJlY3RvcnknKVxuICAgKiAgIC5vcHRpb24oJy1jLCAtLWNvbmZpZyA8cGF0aD4nLCAnc2V0IGNvbmZpZyBwYXRoLiBkZWZhdWx0cyB0byAuL2RlcGxveS5jb25mJylcbiAgICogICAub3B0aW9uKCctVCwgLS1uby10ZXN0cycsICdpZ25vcmUgdGVzdCBob29rJylcbiAgICpcbiAgICogcHJvZ1xuICAgKiAgIC5jb21tYW5kKCdzZXR1cCcpXG4gICAqICAgLmRlc2NyaXB0aW9uKCdydW4gcmVtb3RlIHNldHVwIGNvbW1hbmRzJylcbiAgICogICAuYWN0aW9uKCgpID0+IHtcbiAgICogICAgIGNvbnNvbGUubG9nKCdzZXR1cCcpO1xuICAgKiAgIH0pO1xuICAgKlxuICAgKiBwcm9nXG4gICAqICAgLmNvbW1hbmQoJ2V4ZWMgPGNtZD4nKVxuICAgKiAgIC5kZXNjcmlwdGlvbigncnVuIHRoZSBnaXZlbiByZW1vdGUgY29tbWFuZCcpXG4gICAqICAgLmFjdGlvbigoY21kKSA9PiB7XG4gICAqICAgICBjb25zb2xlLmxvZygnZXhlYyBcIiVzXCInLCBjbWQpO1xuICAgKiAgIH0pO1xuICAgKlxuICAgKiBwcm9nXG4gICAqICAgLmNvbW1hbmQoJ3RlYXJkb3duIDxkaXI+IFtvdGhlckRpcnMuLi5dJylcbiAgICogICAuZGVzY3JpcHRpb24oJ3J1biB0ZWFyZG93biBjb21tYW5kcycpXG4gICAqICAgLmFjdGlvbigoZGlyLCBvdGhlckRpcnMpID0+IHtcbiAgICogICAgIGNvbnNvbGUubG9nKCdkaXIgXCIlc1wiJywgZGlyKTtcbiAgICogICAgIGlmIChvdGhlckRpcnMpIHtcbiAgICogICAgICAgb3RoZXJEaXJzLmZvckVhY2goKG9EaXIpID0+IHtcbiAgICogICAgICAgICBjb25zb2xlLmxvZygnZGlyIFwiJXNcIicsIG9EaXIpO1xuICAgKiAgICAgICB9KTtcbiAgICogICAgIH1cbiAgICogICB9KTtcbiAgICpcbiAgICogcHJvZ1xuICAgKiAgIC5jb21tYW5kKCcqJylcbiAgICogICAuZGVzY3JpcHRpb24oJ2RlcGxveSB0aGUgZ2l2ZW4gZW52JylcbiAgICogICAuYWN0aW9uKChlbnYpID0+IHtcbiAgICogICAgIGNvbnNvbGUubG9nKCdkZXBsb3lpbmcgXCIlc1wiJywgZW52KTtcbiAgICogICB9KTtcbiAgICpcbiAgICogcHJvZy5wYXJzZShwcm9jZXNzLmFyZ3YpO1xuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIG5hbWVcbiAgICogQHBhcmFtIFtkZXNjXSBmb3IgZ2l0LXN0eWxlIHN1Yi1jb21tYW5kc1xuICAgKiBAcmV0dXJucyBbW0NvbW1hbmRdXSB0aGUgbmV3IGNvbW1hbmRcbiAgICovXG4gIHB1YmxpYyBjb21tYW5kKFxuICAgIG5hbWU6IHN0cmluZyxcbiAgICBkZXNjPzogc3RyaW5nIHwgbnVsbCxcbiAgICBvcHRzOiB7IGlzRGVmYXVsdD86IGJvb2xlYW47IG5vSGVscD86IGJvb2xlYW4gfSA9IHtcbiAgICAgIGlzRGVmYXVsdDogZmFsc2UsXG4gICAgICBub0hlbHA6IGZhbHNlXG4gICAgfVxuICApOiBDb21tYW5kIHtcbiAgICBpZiAodHlwZW9mIGRlc2MgPT09ICdvYmplY3QnICYmIGRlc2MgIT0gbnVsbCkge1xuICAgICAgb3B0cyA9IGRlc2M7XG4gICAgICBkZXNjID0gbnVsbDtcbiAgICB9XG4gICAgb3B0cyA9IG9wdHMgfHwge307XG4gICAgY29uc3QgYXJncyA9IG5hbWUuc3BsaXQoLyArLyk7XG4gICAgY29uc3QgY21kID0gbmV3IENvbW1hbmQoYXJncy5zaGlmdCgpKTtcblxuICAgIGlmIChkZXNjICYmIGNtZC5fbmFtZSkge1xuICAgICAgY21kLmRlc2NyaXB0aW9uKGRlc2MpO1xuICAgICAgdGhpcy5leGVjdXRhYmxlcyA9IHRydWU7XG4gICAgICB0aGlzLmV4ZWNzW2NtZC5fbmFtZV0gPSB0cnVlO1xuICAgICAgaWYgKG9wdHMuaXNEZWZhdWx0KSB7XG4gICAgICAgIHRoaXMuZGVmYXVsdEV4ZWN1dGFibGUgPSBjbWQuX25hbWU7XG4gICAgICB9XG4gICAgfVxuICAgIGNtZC5ub0hlbHAgPSAhIW9wdHMubm9IZWxwO1xuICAgIHRoaXMuY29tbWFuZHMucHVzaChjbWQpO1xuICAgIGNtZC5wYXJzZUV4cGVjdGVkQXJncyhhcmdzKTtcbiAgICBjbWQucGFyZW50ID0gdGhpcztcblxuICAgIGlmIChkZXNjKSByZXR1cm4gdGhpcztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZpbmUgYXJndW1lbnQgc3ludGF4IGZvciB0aGUgdG9wLWxldmVsIGNvbW1hbmQuXG4gICAqL1xuICBwdWJsaWMgYXJndW1lbnRzKGRlc2M6IHN0cmluZyk6IENvbW1hbmQge1xuICAgIHJldHVybiB0aGlzLnBhcnNlRXhwZWN0ZWRBcmdzKGRlc2Muc3BsaXQoLyArLykpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhbiBpbXBsaWNpdCBgaGVscCBbY21kXWAgc3ViY29tbWFuZFxuICAgKiB3aGljaCBpbnZva2VzIGAtLWhlbHBgIGZvciB0aGUgZ2l2ZW4gY29tbWFuZC5cbiAgICovXG4gIHByaXZhdGUgYWRkSW1wbGljaXRIZWxwQ29tbWFuZCgpOiB2b2lkIHtcbiAgICB0aGlzLmNvbW1hbmQoJ2hlbHAgW2NtZF0nLCAnZGlzcGxheSBoZWxwIGZvciBbY21kXScpO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlIGV4cGVjdGVkIGBhcmdzYC5cbiAgICpcbiAgICogRm9yIGV4YW1wbGUgYFtcIlt0eXBlXVwiXWAgYmVjb21lcyBgW3sgcmVxdWlyZWQ6IGZhbHNlLCBuYW1lOiAndHlwZScgfV1gLlxuICAgKi9cbiAgcHJpdmF0ZSBwYXJzZUV4cGVjdGVkQXJncyhhcmdzOiBzdHJpbmdbXSk6IENvbW1hbmQge1xuICAgIGlmICghYXJncy5sZW5ndGgpIHRoaXM7XG5cbiAgICBhcmdzLmZvckVhY2goYXJnID0+IHtcbiAgICAgIGNvbnN0IGFyZ0RldGFpbHMgPSB7XG4gICAgICAgIHJlcXVpcmVkOiBmYWxzZSxcbiAgICAgICAgbmFtZTogJycsXG4gICAgICAgIHZhcmlhZGljOiBmYWxzZVxuICAgICAgfTtcblxuICAgICAgc3dpdGNoIChhcmdbMF0pIHtcbiAgICAgICAgY2FzZSAnPCc6XG4gICAgICAgICAgYXJnRGV0YWlscy5yZXF1aXJlZCA9IHRydWU7XG4gICAgICAgICAgYXJnRGV0YWlscy5uYW1lID0gYXJnLnNsaWNlKDEsIC0xKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnWyc6XG4gICAgICAgICAgYXJnRGV0YWlscy5uYW1lID0gYXJnLnNsaWNlKDEsIC0xKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaWYgKGFyZ0RldGFpbHMubmFtZS5sZW5ndGggPiAzICYmIGFyZ0RldGFpbHMubmFtZS5zbGljZSgtMykgPT09ICcuLi4nKSB7XG4gICAgICAgIGFyZ0RldGFpbHMudmFyaWFkaWMgPSB0cnVlO1xuICAgICAgICBhcmdEZXRhaWxzLm5hbWUgPSBhcmdEZXRhaWxzLm5hbWUuc2xpY2UoMCwgLTMpO1xuICAgICAgfVxuICAgICAgaWYgKGFyZ0RldGFpbHMubmFtZSkge1xuICAgICAgICB0aGlzLl9hcmdzLnB1c2goYXJnRGV0YWlscyk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXIgYSBjYWxsYmFjayBmb3IgYSBjb21tYW5kXG4gICAqXG4gICAqIEV4YW1wbGVzOlxuICAgKiBgYGB0c1xuICAgKiBwcm9ncmFtKClcbiAgICogICAuY29tbWFuZCgnaGVscCcpXG4gICAqICAgLmRlc2NyaXB0aW9uKCdkaXNwbGF5IHZlcmJvc2UgaGVscCcpXG4gICAqICAgLmFjdGlvbigoKSA9PiB7XG4gICAqICAgICAgLy8gb3V0cHV0IGhlbHAgaGVyZVxuICAgKiAgIH0pO1xuICAgKiBgYGBcbiAgICogQHBhcmFtIGZuXG4gICAqIEByZXR1cm5zIFtbQ29tbWFuZF1dIGZvciBjaGFpbmluZ1xuICAgKi9cbiAgcHVibGljIGFjdGlvbihmbjogRnVuY3Rpb24pOiBDb21tYW5kIHtcbiAgICBjb25zdCBsaXN0ZW5lciA9IChcbiAgICAgIGFyZ3M6IChzdHJpbmcgfCBDb21tYW5kIHwgYW55W10pW10gPSBbXSxcbiAgICAgIHVua25vd246IHN0cmluZ1tdID0gW11cbiAgICApID0+IHtcbiAgICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMucGFyc2VPcHRpb25zKHVua25vd24pO1xuXG4gICAgICAvLyBPdXRwdXQgaGVscCBpZiBuZWNlc3NhcnlcbiAgICAgIG91dHB1dEhlbHBJZk5lY2Vzc2FyeSh0aGlzLCBwYXJzZWQudW5rbm93bik7XG5cbiAgICAgIC8vIElmIHRoZXJlIGFyZSBzdGlsbCBhbnkgdW5rbm93biBvcHRpb25zLCB0aGVuIHdlIHNpbXBseVxuICAgICAgLy8gZGllLCB1bmxlc3Mgc29tZW9uZSBhc2tlZCBmb3IgaGVscCwgaW4gd2hpY2ggY2FzZSB3ZSBnaXZlIGl0XG4gICAgICAvLyB0byB0aGVtLCBhbmQgdGhlbiB3ZSBkaWUuXG4gICAgICBpZiAocGFyc2VkLnVua25vd24ubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLnVua25vd25PcHRpb24ocGFyc2VkLnVua25vd25bMF0pO1xuICAgICAgfVxuXG4gICAgICAvLyBMZWZ0b3ZlciBhcmd1bWVudHMgbmVlZCB0byBiZSBwdXNoZWQgYmFjay4gRml4ZXMgaXNzdWUgIzU2XG4gICAgICBpZiAocGFyc2VkLmFyZ3MubGVuZ3RoKSBhcmdzID0gcGFyc2VkLmFyZ3MuY29uY2F0KGFyZ3MgYXMgQXJncyk7XG5cbiAgICAgIHRoaXMuX2FyZ3MuZm9yRWFjaCgoYXJnLCBpKSA9PiB7XG4gICAgICAgIGlmIChhcmcucmVxdWlyZWQgJiYgYXJnc1tpXSA9PSBudWxsKSB7XG4gICAgICAgICAgdGhpcy5taXNzaW5nQXJndW1lbnQoYXJnLm5hbWUpO1xuICAgICAgICB9IGVsc2UgaWYgKGFyZy52YXJpYWRpYykge1xuICAgICAgICAgIGlmIChpICE9PSB0aGlzLl9hcmdzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIHRoaXMudmFyaWFkaWNBcmdOb3RMYXN0KGFyZy5uYW1lKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhcmdzW2ldID0gYXJncy5zcGxpY2UoaSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICAvLyBBbHdheXMgYXBwZW5kIG91cnNlbHZlcyB0byB0aGUgZW5kIG9mIHRoZSBhcmd1bWVudHMsXG4gICAgICAvLyB0byBtYWtlIHN1cmUgd2UgbWF0Y2ggdGhlIG51bWJlciBvZiBhcmd1bWVudHMgdGhlIHVzZXJcbiAgICAgIC8vIGV4cGVjdHNcbiAgICAgIGlmICh0aGlzLl9hcmdzLmxlbmd0aCkge1xuICAgICAgICBhcmdzW3RoaXMuX2FyZ3MubGVuZ3RoXSA9IHRoaXM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhcmdzLnB1c2godGhpcyk7XG4gICAgICB9XG5cbiAgICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH07XG4gICAgY29uc3QgcGFyZW50ID0gdGhpcy5wYXJlbnQgfHwgdGhpcztcbiAgICBjb25zdCBuYW1lID0gcGFyZW50ID09PSB0aGlzID8gJyonIDogdGhpcy5fbmFtZTtcbiAgICBwYXJlbnQub24oYGNvbW1hbmQ6JHtuYW1lfWAsIGxpc3RlbmVyKTtcbiAgICBpZiAodGhpcy5fYWxpYXMpIHBhcmVudC5vbihgY29tbWFuZDoke3RoaXMuX2FsaWFzfWAsIGxpc3RlbmVyKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZpbmUgb3B0aW9uIHdpdGggYGZsYWdzYCwgYGRlc2NyaXB0aW9uYCBhbmQgb3B0aW9uYWxcbiAgICogY29lcmNpb24gYGZuYC5cbiAgICpcbiAgICogVGhlIGBmbGFnc2Agc3RyaW5nIHNob3VsZCBjb250YWluIGJvdGggdGhlIHNob3J0IGFuZCBsb25nIGZsYWdzLFxuICAgKiBzZXBhcmF0ZWQgYnkgY29tbWEsIGEgcGlwZSBvciBzcGFjZS4gVGhlIGZvbGxvd2luZyBhcmUgYWxsIHZhbGlkXG4gICAqIGFsbCB3aWxsIG91dHB1dCB0aGlzIHdheSB3aGVuIGAtLWhlbHBgIGlzIHVzZWQuXG4gICAqXG4gICAqICogXCItcCwgLS1wZXBwZXJcIlxuICAgKiAqIFwiLXB8LS1wZXBwZXJcIlxuICAgKiAqIFwiLXAgLS1wZXBwZXJcIlxuICAgKlxuICAgKiBFeGFtcGxlczpcbiAgICogYGBgdHNcbiAgICogLy8gc2ltcGxlIGJvb2xlYW4gZGVmYXVsdGluZyB0byBmYWxzZVxuICAgKiBwcm9ncmFtLm9wdGlvbignLXAsIC0tcGVwcGVyJywgJ2FkZCBwZXBwZXInKTtcbiAgICpcbiAgICogLy8gLS1wZXBwZXJcbiAgICogcHJvZ3JhbS5wZXBwZXJcbiAgICogLy8gPT4gQm9vbGVhblxuICAgKlxuICAgKiAvLyBzaW1wbGUgYm9vbGVhbiBkZWZhdWx0aW5nIHRvIHRydWVcbiAgICogcHJvZ3JhbS5vcHRpb24oJy1DLCAtLW5vLWNoZWVzZScsICdyZW1vdmUgY2hlZXNlJyk7XG4gICAqXG4gICAqIHByb2dyYW0uY2hlZXNlXG4gICAqIC8vID0+IHRydWVcbiAgICpcbiAgICogLy8gLS1uby1jaGVlc2VcbiAgICogcHJvZ3JhbS5jaGVlc2VcbiAgICogLy8gPT4gZmFsc2VcbiAgICpcbiAgICogLy8gcmVxdWlyZWQgYXJndW1lbnRcbiAgICogcHJvZ3JhbS5vcHRpb24oJy1DLCAtLWNoZGlyIDxwYXRoPicsICdjaGFuZ2UgdGhlIHdvcmtpbmcgZGlyZWN0b3J5Jyk7XG4gICAqXG4gICAqIC8vIC0tY2hkaXIgL3RtcFxuICAgKiBwcm9ncmFtLmNoZGlyXG4gICAqIC8vID0+IFwiL3RtcFwiXG4gICAqXG4gICAqIC8vIG9wdGlvbmFsIGFyZ3VtZW50XG4gICAqIHByb2dyYW0ub3B0aW9uKCctYywgLS1jaGVlc2UgW3R5cGVdJywgJ2FkZCBjaGVlc2UgW21hcmJsZV0nKTtcbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSBmbGFnc1xuICAgKiBAcGFyYW0gZGVzY3JpcHRpb25cbiAgICogQHBhcmFtIGZuXG4gICAqIEBwYXJhbSBkZWZhdWx0VmFsdWVcbiAgICogQHJldHVybnMgW1tDb21tYW5kXV0gZm9yIGNoYWluaW5nXG4gICAqL1xuICBwdWJsaWMgb3B0aW9uKFxuICAgIGZsYWdzOiBzdHJpbmcsXG4gICAgZGVzY3JpcHRpb246IHN0cmluZyxcbiAgICBmbj86IEZ1bmN0aW9uIHwgUmVnRXhwLFxuICAgIGRlZmF1bHRWYWx1ZT86IGFueVxuICApOiBDb21tYW5kIHtcbiAgICBjb25zdCBvcHRpb24gPSBuZXcgT3B0aW9uKGZsYWdzLCBkZXNjcmlwdGlvbik7XG4gICAgY29uc3Qgb3B0aW9uTmFtZSA9IG9wdGlvbi5uYW1lKCk7XG4gICAgY29uc3QgbmFtZSA9IG9wdGlvbi5hdHRyaWJ1dGVOYW1lKCk7XG5cbiAgICAvLyBkZWZhdWx0IGFzIDNyZCBhcmdcbiAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoZm4gaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgY29uc3QgcmVnZXg6IFJlZ0V4cCA9IGZuO1xuICAgICAgICBmbiA9ICh2YWw6IGFueSwgZGVmOiBhbnkpID0+IHtcbiAgICAgICAgICBjb25zdCBtID0gcmVnZXguZXhlYyh2YWwpO1xuICAgICAgICAgIHJldHVybiBtID8gbVswXSA6IGRlZjtcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlZmF1bHRWYWx1ZSA9IGZuO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHByZWFzc2lnbiBkZWZhdWx0IHZhbHVlIG9ubHkgZm9yIC0tbm8tKiwgW29wdGlvbmFsXSwgb3IgPHJlcXVpcmVkPlxuICAgIGlmICghb3B0aW9uLmJvb2wgfHwgb3B0aW9uLm9wdGlvbmFsIHx8IG9wdGlvbi5yZXF1aXJlZCkge1xuICAgICAgLy8gd2hlbiAtLW5vLSogd2UgbWFrZSBzdXJlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAgaWYgKCFvcHRpb24uYm9vbCkgZGVmYXVsdFZhbHVlID0gdHJ1ZTtcbiAgICAgIC8vIHByZWFzc2lnbiBvbmx5IGlmIHdlIGhhdmUgYSBkZWZhdWx0XG4gICAgICBpZiAoZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpc1tuYW1lXSA9IGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgb3B0aW9uLmRlZmF1bHRWYWx1ZSA9IGRlZmF1bHRWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyByZWdpc3RlciB0aGUgb3B0aW9uXG4gICAgdGhpcy5vcHRpb25zLnB1c2gob3B0aW9uKTtcblxuICAgIC8vIHdoZW4gaXQncyBwYXNzZWQgYXNzaWduIHRoZSB2YWx1ZVxuICAgIC8vIGFuZCBjb25kaXRpb25hbGx5IGludm9rZSB0aGUgY2FsbGJhY2tcbiAgICB0aGlzLm9uKGBvcHRpb246JHtvcHRpb25OYW1lfWAsIHZhbCA9PiB7XG4gICAgICAvLyBjb2VyY2lvblxuICAgICAgaWYgKHZhbCAhPSBudWxsICYmIHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YWwgPSBmbih2YWwsIHRoaXNbbmFtZV0gPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRWYWx1ZSA6IHRoaXNbbmFtZV0pO1xuICAgICAgfVxuXG4gICAgICAvLyB1bmFzc2lnbmVkIG9yIGJvb2xcbiAgICAgIGlmIChcbiAgICAgICAgdHlwZW9mIHRoaXNbbmFtZV0gPT09ICdib29sZWFuJyB8fFxuICAgICAgICB0eXBlb2YgdGhpc1tuYW1lXSA9PT0gJ3VuZGVmaW5lZCdcbiAgICAgICkge1xuICAgICAgICAvLyBpZiBubyB2YWx1ZSwgYm9vbCB0cnVlLCBhbmQgd2UgaGF2ZSBhIGRlZmF1bHQsIHRoZW4gdXNlIGl0IVxuICAgICAgICBpZiAodmFsID09IG51bGwpIHtcbiAgICAgICAgICB0aGlzW25hbWVdID0gb3B0aW9uLmJvb2wgPyBkZWZhdWx0VmFsdWUgfHwgdHJ1ZSA6IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXNbbmFtZV0gPSB2YWw7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodmFsICE9IG51bGwpIHtcbiAgICAgICAgLy8gcmVhc3NpZ25cbiAgICAgICAgdGhpc1tuYW1lXSA9IHZhbDtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdmFsdWUgb2YgYW4gb3B0aW9uXG4gICAqXG4gICAqIEBwYXJhbSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIG9wdGlvbiB5b3Ugd2FudCB0byBnZXRcbiAgICogQHJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSByZXF1ZXN0ZWQgb3B0aW9uXG4gICAqL1xuICBwdWJsaWMgZ2V0KG5hbWU6IHN0cmluZyk6IGJvb2xlYW4gfCBzdHJpbmcgfCBudW1iZXIge1xuICAgIGlmICghKG5hbWUgaW4gdGhpcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgT3B0aW9uIFwiJHtuYW1lfVwiIGRvZXMgbm90IGV4aXN0YCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzW25hbWVdO1xuICB9XG5cbiAgLyoqXG4gICAqIEFsbG93IHVua25vd24gb3B0aW9ucyBvbiB0aGUgY29tbWFuZCBsaW5lLlxuICAgKlxuICAgKiBAcGFyYW0gYXJnIC0gaWYgYGZhbHNlYCwgZXJyb3Igd2lsbCBiZSB0aHJvd24gaWYgdW5rbm93biBvcHRpb24gcGFzc2VkLiBEZWZhdWx0cyB0byBgZmFsc2VgXG4gICAqIGZvciB1bmtub3duIG9wdGlvbnMuXG4gICAqL1xuICBwdWJsaWMgYWxsb3dVbmtub3duT3B0aW9uKGFyZzogYm9vbGVhbiA9IGZhbHNlKTogQ29tbWFuZCB7XG4gICAgdGhpcy5fYWxsb3dVbmtub3duT3B0aW9uID0gYXJnO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmluZSBjb21wbGV0aW9uIHJ1bGVzIHdoaWNoIHdpbGwgbGF0ZXIgYmUgdXNlZCBieSBhdXRvY29tcGxldGUgdG8gZ2VuZXJhdGUgYXBwcm9wcmlhdGUgcmVzcG9uc2VcbiAgICpcbiAgICogYGBganNcbiAgICogcHJvZ3JhbSgpXG4gICAqICAgLmFyZ3VtZW50cygnPGE+IDxiPicpXG4gICAqICAgLm9wdGlvbignLS12ZXJib3NlJywgJ3ZlcmJvc2UnKVxuICAgKiAgIC5vcHRpb24oJy1uLCAtLW5hbWUgPG5hbWU+JywgJ3NwZWNpZnkgbmFtZScpXG4gICAqICAgLm9wdGlvbignLS1kZXNjcmlwdGlvbiA8ZGVzYz4nLCAnc3BlY2lmeSBkZXNjcmlwdGlvbicpXG4gICAqICAgLmNvbXBsZXRlKHtcbiAgICogICAgIG9wdGlvbnM6IHtcbiAgICogICAgICAgJy0tbmFtZSc6ICh0eXBlZEFyZ3MpID0+IFsna2F0ZScsICdqaW0nXSxcbiAgICogICAgICAgJy0tZGVzY3JpcHRpb24nOiBbJ2Rlc2MxJywgJ2Rlc2MyJ11cbiAgICogICAgIH0sXG4gICAqICAgICBhcmd1bWVudHM6IHtcbiAgICogICAgICAgYTogKHR5cGVkQXJncykgPT4gWydhLTEnLCAnYS0yJ10sXG4gICAqICAgICAgIGI6IFsnYi0xJywgJ2ItMiddXG4gICAqICAgICB9XG4gICAqICAgfSk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0gY29tcGxldGlvbiAtIHJ1bGVzXG4gICAqL1xuICBwdWJsaWMgY29tcGxldGUocnVsZXM6IHtcbiAgICBvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmdbXSB8IEZ1bmN0aW9uPjtcbiAgICBhcmd1bWVudHM6IHtcbiAgICAgIGZpbGVuYW1lOiBzdHJpbmdbXTtcbiAgICAgIGFyZ3M6IHN0cmluZ1tdO1xuICAgICAgdXJsOiBzdHJpbmdbXTtcbiAgICB9O1xuICAgIGFyZ3M6IHN0cmluZ1tdO1xuICB9KTogQ29tbWFuZCB7XG4gICAgLy8gbWVyZ2Ugb3B0aW9uc1xuICAgIC8vIHRoaXMgc2hvdWxkIGVuc3VyZSB0aGlzLl9jb21wbGV0aW9uUnVsZXMgYXJlIGFsd2F5cyBpbiBzaGFwZVxuICAgIGlmIChydWxlcy5vcHRpb25zKSB7XG4gICAgICB0aGlzLl9jb21wbGV0aW9uUnVsZXMub3B0aW9ucyA9IHJ1bGVzLm9wdGlvbnM7XG4gICAgfVxuXG4gICAgLy8gc3VwcG9ydCBib3RoIGFyZ3VtZW50cyBvciBhcmdzIGFzIGtleVxuICAgIGlmIChydWxlcy5hcmd1bWVudHMpIHtcbiAgICAgIHRoaXMuX2NvbXBsZXRpb25SdWxlcy5hcmdzID0gcnVsZXMuYXJndW1lbnRzO1xuICAgIH0gZWxzZSBpZiAocnVsZXMuYXJncykge1xuICAgICAgdGhpcy5fY29tcGxldGlvblJ1bGVzLmFyZ3MgPSBydWxlcy5hcmdzO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFRlc3QgaWYgYW55IGNvbXBsZXRlIHJ1bGVzIGhhcyBiZWVuIGRlZmluZWQgZm9yIGN1cnJlbnQgY29tbWFuZCBvciBpdHMgc3ViY29tbWFuZHMuXG4gICAqXG4gICAqIEByZXR1cm5zIGlmIGFueSBjb21wbGV0ZSBydWxlcyBoYXMgYmVlbiBkZWZpbmVkIGZvciBjdXJyZW50IGNvbW1hbmQgb3IgaXRzIHN1YmNvbW1hbmRzLlxuICAgKi9cbiAgcHJpdmF0ZSBoYXNDb21wbGV0aW9uUnVsZXMoKTogYm9vbGVhbiB7XG4gICAgZnVuY3Rpb24gaXNFbXB0eVJ1bGUoe1xuICAgICAgb3B0aW9ucyxcbiAgICAgIGFyZ3NcbiAgICB9OiB7XG4gICAgICBvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+O1xuICAgICAgYXJnczogUmVjb3JkPHN0cmluZywgYW55PjtcbiAgICB9KSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICBPYmplY3Qua2V5cyhvcHRpb25zKS5sZW5ndGggPT09IDAgJiYgT2JqZWN0LmtleXMoYXJncykubGVuZ3RoID09PSAwXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiAhKFxuICAgICAgaXNFbXB0eVJ1bGUodGhpcy5fY29tcGxldGlvblJ1bGVzKSAmJlxuICAgICAgdGhpcy5jb21tYW5kcy5ldmVyeSgoeyBfY29tcGxldGlvblJ1bGVzIH0pID0+XG4gICAgICAgIGlzRW1wdHlSdWxlKF9jb21wbGV0aW9uUnVsZXMpXG4gICAgICApXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgYXV0b2NvbXBsZXRlIGlmIGNvbW1hbmQgYXJncyBzdGFydHMgd2l0aCBzcGVjaWFsIG9wdGlvbnMuXG4gICAqIEl0IHdpbGwgZXhpdCBjdXJyZW50IHByb2Nlc3MgYWZ0ZXIgc3VjY2Vzc2Z1bCBwcm9jZXNzaW5nLlxuICAgKlxuICAgKiBAcmV0dXJucyBbW0NvbW1hbmRdXSBmcm9tIGNoYWluaW5nXG4gICAqL1xuICBwdWJsaWMgYXV0b2NvbXBsZXRlKGFyZ3Y6IHN0cmluZ1tdKTogQ29tbWFuZCB7XG4gICAgY29uc3QgUkVTRVJWRURfU1RBUlRJTkdfS0VZV09SRFMgPSBbXG4gICAgICAnLS1jb21wbGV0aW9uJyxcbiAgICAgICctLWNvbXBsZXRpb24tZmlzaCcsXG4gICAgICAnLS1jb21wenNoJyxcbiAgICAgICctLWNvbXBiYXNoJyxcbiAgICAgICctLWNvbXBmaXNoJ1xuICAgIF07XG4gICAgY29uc3QgZmlyc3RBcmcgPSBhcmd2WzJdO1xuXG4gICAgaWYgKFJFU0VSVkVEX1NUQVJUSU5HX0tFWVdPUkRTLmluY2x1ZGVzKGZpcnN0QXJnKSkge1xuICAgICAgLy8gbGF6eSByZXF1aXJlXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXZhci1yZXF1aXJlc1xuICAgICAgY29uc3Qgb21lbGV0dGUgPSByZXF1aXJlKCdvbWVsZXR0ZScpO1xuICAgICAgY29uc3QgZXhlY3V0YWJsZU5hbWUgPSBwYXRoLmJhc2VuYW1lKGFyZ3ZbMV0sICcuanMnKTtcbiAgICAgIGNvbnN0IGNvbXBsZXRpb24gPSBvbWVsZXR0ZShleGVjdXRhYmxlTmFtZSk7XG5cbiAgICAgIGNvbXBsZXRpb24ub24oJ2NvbXBsZXRlJywgKF9mOiBGdW5jdGlvbiwgZXZlbnQ6IEF1dG9jb21wbGV0ZUV2ZW50KSA9PiB7XG4gICAgICAgIHRoaXMuYXV0b2NvbXBsZXRlSGFuZGxlRXZlbnQoZXZlbnQpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIG9tZWxldHRlIHdpbGwgY2FsbCBwcm9jZXNzLmV4aXQoMClcbiAgICAgIGNvbXBsZXRpb24uaW5pdCgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBvbWVsZXR0ZSBjb21wbGV0ZSBldmVudFxuICAgKlxuICAgKiBAcGFyYW0gb21lbGV0dGUgZXZlbnQgd2hpY2ggY29udGFpbnMgZnJhZ21lbnQsIGxpbmUsIHJlcGx5IGluZm9cbiAgICovXG4gIHByaXZhdGUgYXV0b2NvbXBsZXRlSGFuZGxlRXZlbnQoZXZlbnQ6IEF1dG9jb21wbGV0ZUV2ZW50KTogdm9pZCB7XG4gICAgaWYgKHRoaXMuY29tbWFuZHMubGVuZ3RoID4gMCkge1xuICAgICAgLy8gc3ViIGNvbW1hbmQgc3R5bGVcbiAgICAgIGlmIChldmVudC5mcmFnbWVudCA9PT0gMSkge1xuICAgICAgICAvLyBmb3Igc3ViIGNvbW1hbmQgZmlyc3QgY29tcGxldGUgc2hvdWxkIHJldHVybiBjb21tYW5kXG4gICAgICAgIGNvbnN0IGNvbW1hbmRzID0gdGhpcy5jb21tYW5kcy5tYXAoYyA9PiBjLmdldE5hbWUoKSk7XG5cbiAgICAgICAgZXZlbnQucmVwbHkoY29tbWFuZHMuY29uY2F0KFsnLS1oZWxwJ10pKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnRzID0gZXZlbnQubGluZS5zcGxpdCgnICcpO1xuICAgICAgICBjb25zdCBjb21tYW5kTmFtZSA9IGVsZW1lbnRzWzFdO1xuICAgICAgICBjb25zdCBjb21tYW5kQXJncyA9IGVsZW1lbnRzLnNsaWNlKDIsIGV2ZW50LmZyYWdtZW50KTtcbiAgICAgICAgY29uc3QgY3VycmVudENvbW1hbmQgPSB0aGlzLmNvbW1hbmRzLmZpbmQoXG4gICAgICAgICAgYyA9PiBjLmdldE5hbWUoKSA9PT0gY29tbWFuZE5hbWVcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAoY3VycmVudENvbW1hbmQpIHtcbiAgICAgICAgICBldmVudC5yZXBseShjdXJyZW50Q29tbWFuZC5hdXRvY29tcGxldGVDYW5kaWRhdGVzKGNvbW1hbmRBcmdzKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXZlbnQucmVwbHkoW10pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHNpbmdsZSBjb21tYW5kIHN0eWxlXG4gICAgICBjb25zdCBzaW5nbGVDb21tYW5kQXJncyA9IGV2ZW50LmxpbmUuc3BsaXQoJyAnKS5zbGljZSgxLCBldmVudC5mcmFnbWVudCk7XG5cbiAgICAgIGlmIChldmVudC5mcmFnbWVudCA9PT0gMSkge1xuICAgICAgICAvLyBvZmZlciAtLWhlbHAgZm9yIHRoZSBmaXJzdCBjb21wbGV0ZSBvbmx5XG4gICAgICAgIGV2ZW50LnJlcGx5KFxuICAgICAgICAgIHRoaXMuYXV0b2NvbXBsZXRlQ2FuZGlkYXRlcyhzaW5nbGVDb21tYW5kQXJncykuY29uY2F0KFsnLS1oZWxwJ10pXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBldmVudC5yZXBseSh0aGlzLmF1dG9jb21wbGV0ZUNhbmRpZGF0ZXMoc2luZ2xlQ29tbWFuZEFyZ3MpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IGNhbmRpZGF0ZXMgYmFzZSBvbiBjdXJyZW50IGxpbmUgaW5wdXQgYW5kIGNvbXBsZXRpb25SdWxlcy5cbiAgICogVGhpcyBpcyB0aGUgY29yZSBvZiBzbWFydCBsb2dpYyBvZiBhdXRvY29tcGxldGlvblxuICAgKlxuICAgKiBAcGFyYW0gdHlwZWQgYXJnc1xuICAgKiBAcmV0dXJucyBhdXRvIGNvbXBsZXRlIGNhbmRpZGF0ZXNcbiAgICovXG4gIHByaXZhdGUgYXV0b2NvbXBsZXRlQ2FuZGlkYXRlcyh0eXBlZEFyZ3M6IHN0cmluZ1tdKTogc3RyaW5nW10ge1xuICAgIGNvbnN0IGNvbXBsZXRpb25SdWxlcyA9IHRoaXMuYXV0b2NvbXBsZXRlTm9ybWFsaXplUnVsZXMoKTtcbiAgICBjb25zdCBhY3RpdmVPcHRpb24gPSBhdXRvY29tcGxldGVBY3RpdmVPcHRpb24oXG4gICAgICBjb21wbGV0aW9uUnVsZXMub3B0aW9ucyxcbiAgICAgIHR5cGVkQXJnc1xuICAgICk7XG5cbiAgICBpZiAoYWN0aXZlT3B0aW9uKSB7XG4gICAgICAvLyBpZiBjdXJyZW50IHR5cGVkQXJncyBzdWdnZXN0cyBpdCdzIGZpbGxpbmcgYW4gb3B0aW9uXG4gICAgICAvLyBuZXh0IHZhbHVlIHdvdWxkIGJlIHRoZSBwb3NzaWJsZSB2YWx1ZXMgZm9yIHRoYXQgb3B0aW9uXG4gICAgICBjb25zdCB7IHJlcGx5IH0gPSBhY3RpdmVPcHRpb247XG5cbiAgICAgIGlmICh0eXBlb2YgcmVwbHkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIHJlcGx5KHR5cGVkQXJncykgfHwgW107XG4gICAgICB9XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShyZXBseSkpIHtcbiAgICAgICAgcmV0dXJuIHJlcGx5O1xuICAgICAgfVxuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICAvLyBvdGhlcndpc2VcbiAgICAvLyBuZXh0IHZhbHVlIHdvdWxkIGJlIG9uZSBvZiB0aGUgdW51c2VkIG9wdGlvbiBuYW1lc1xuICAgIGNvbnN0IG9wdGlvbk5hbWVzID0gT2JqZWN0LmtleXMoY29tcGxldGlvblJ1bGVzLm9wdGlvbnMpLmZpbHRlcihuYW1lID0+IHtcbiAgICAgIGNvbnN0IG9wdGlvbiA9IGNvbXBsZXRpb25SdWxlcy5vcHRpb25zW25hbWVdO1xuXG4gICAgICBpZiAob3B0aW9uLnNpYmxpbmcpIHtcbiAgICAgICAgLy8gcmVtb3ZlIGJvdGggb3B0aW9uIGFuZCBpdHMgc2libGluZyBmb3JtXG4gICAgICAgIHJldHVybiAhdHlwZWRBcmdzLmluY2x1ZGVzKG5hbWUpICYmICF0eXBlZEFyZ3MuaW5jbHVkZXMob3B0aW9uLnNpYmxpbmcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuICF0eXBlZEFyZ3MuaW5jbHVkZXMobmFtZSk7XG4gICAgfSk7XG5cbiAgICAvLyBvciBwb3NzaWJsZSB2YWx1ZXMgZm9yIG5leHQgYXJndW1lbnRzXG4gICAgY29uc3QgYWN0aXZlQXJnID0gYXV0b2NvbXBsZXRlQWN0aXZlQXJnKFxuICAgICAgY29tcGxldGlvblJ1bGVzLm9wdGlvbnMsXG4gICAgICBjb21wbGV0aW9uUnVsZXMuYXJncyxcbiAgICAgIHR5cGVkQXJnc1xuICAgICk7XG5cbiAgICBpZiAodHlwZW9mIGFjdGl2ZUFyZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIG9wdGlvbk5hbWVzLmNvbmNhdChhY3RpdmVBcmcodHlwZWRBcmdzKSB8fCBbXSk7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KGFjdGl2ZUFyZykpIHtcbiAgICAgIHJldHVybiBvcHRpb25OYW1lcy5jb25jYXQoYWN0aXZlQXJnKTtcbiAgICB9XG4gICAgcmV0dXJuIG9wdGlvbk5hbWVzO1xuICB9XG5cbiAgLyoqXG4gICAqIEZvciB0aGUgZWFzZSBvZiBwcm9jZXNzaW5nLFxuICAgKiB0aGUgaW50ZXJuYWwgcHJlc2VudGF0aW9uIG9mIGNvbXBsZXRpb24gcnVsZXMgaXMgcXVpdGUgZGlmZmVyZW50IGZyb20gdXNlciBpbnB1dC5cbiAgICpcbiAgICogQHJldHVybnMgbm9ybWFsaXplZCBydWxlc1xuICAgKi9cbiAgcHJpdmF0ZSBhdXRvY29tcGxldGVOb3JtYWxpemVSdWxlcygpOiB7IG9wdGlvbnM6IHt9OyBhcmdzOiBzdHJpbmdbXSB9IHtcbiAgICAvLyBzdXBwbGVtZW50IHdpdGggaW1wb3J0YW50IGluZm9ybWF0aW9uIGluY2x1ZGluZ1xuICAgIC8vIG9wdGlvbiBhcml0eSBhbmQgc2libGluZ1xuICAgIGNvbnN0IHJhd1J1bGVzID0gdGhpcy5fY29tcGxldGlvblJ1bGVzO1xuICAgIGNvbnN0IHsgb3B0aW9ucyB9ID0gdGhpcztcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYXJncztcbiAgICBjb25zdCBub3JtYWxpemVkUnVsZXM6IHtcbiAgICAgIG9wdGlvbnM6IFJlY29yZDxcbiAgICAgICAgc3RyaW5nLFxuICAgICAgICB7XG4gICAgICAgICAgYXJpdHk6IG51bWJlcjtcbiAgICAgICAgICBzaWJsaW5nOiBzdHJpbmcgfCBudWxsO1xuICAgICAgICAgIHJlcGx5OiBzdHJpbmdbXSB8IEZ1bmN0aW9uO1xuICAgICAgICB9XG4gICAgICA+O1xuICAgICAgYXJnczogc3RyaW5nW107XG4gICAgfSA9IHsgb3B0aW9uczoge30sIGFyZ3M6IFtdIH07XG5cbiAgICBvcHRpb25zLmZvckVhY2gob3B0aW9uID0+IHtcbiAgICAgIGlmIChvcHRpb24uc2hvcnQpIHtcbiAgICAgICAgY29uc3QgcmVwbHkgPVxuICAgICAgICAgIHJhd1J1bGVzLm9wdGlvbnNbb3B0aW9uLmxvbmddIHx8IHJhd1J1bGVzLm9wdGlvbnNbb3B0aW9uLnNob3J0XSB8fCBbXTtcblxuICAgICAgICBub3JtYWxpemVkUnVsZXMub3B0aW9uc1tvcHRpb24uc2hvcnRdID0ge1xuICAgICAgICAgIGFyaXR5OiBvcHRpb24uYXJpdHkoKSxcbiAgICAgICAgICBzaWJsaW5nOiBvcHRpb24ubG9uZyxcbiAgICAgICAgICByZXBseVxuICAgICAgICB9O1xuXG4gICAgICAgIG5vcm1hbGl6ZWRSdWxlcy5vcHRpb25zW29wdGlvbi5sb25nXSA9IHtcbiAgICAgICAgICBhcml0eTogb3B0aW9uLmFyaXR5KCksXG4gICAgICAgICAgc2libGluZzogb3B0aW9uLnNob3J0LFxuICAgICAgICAgIHJlcGx5XG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub3JtYWxpemVkUnVsZXMub3B0aW9uc1tvcHRpb24ubG9uZ10gPSB7XG4gICAgICAgICAgYXJpdHk6IG9wdGlvbi5hcml0eSgpLFxuICAgICAgICAgIHNpYmxpbmc6IG51bGwsXG4gICAgICAgICAgcmVwbHk6IHJhd1J1bGVzLm9wdGlvbnNbb3B0aW9uLmxvbmddIHx8IFtdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBhcmdzLmZvckVhY2goKHsgbmFtZSB9KSA9PiB7XG4gICAgICBub3JtYWxpemVkUnVsZXMuYXJncy5wdXNoKHJhd1J1bGVzLmFyZ3NbbmFtZV0gfHwgW10pO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIG5vcm1hbGl6ZWRSdWxlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZSBgYXJndmAsIHNldHRpbmdzIG9wdGlvbnMgYW5kIGludm9raW5nIGNvbW1hbmRzIHdoZW4gZGVmaW5lZC5cbiAgICpcbiAgICogQHBhcmFtIGFyZ3ZcbiAgICogQHJldHVybnMgW1tDb21tYW5kXV0gZm9yIGNoYWluaW5nXG4gICAqL1xuICBwdWJsaWMgcGFyc2UoYXJndjogQXJncyk6IENvbW1hbmQge1xuICAgIC8vIHRyaWdnZXIgYXV0b2NvbXBsZXRlIGZpcnN0IGlmIHNvbWUgY29tcGxldGlvbiBydWxlcyBoYXZlIGJlZW4gZGVmaW5lZFxuICAgIGlmICh0aGlzLmhhc0NvbXBsZXRpb25SdWxlcygpKSB7XG4gICAgICB0aGlzLmF1dG9jb21wbGV0ZShhcmd2KTtcbiAgICB9XG5cbiAgICAvLyBpbXBsaWNpdCBoZWxwXG4gICAgaWYgKHRoaXMuZXhlY3V0YWJsZXMpIHRoaXMuYWRkSW1wbGljaXRIZWxwQ29tbWFuZCgpO1xuXG4gICAgLy8gc3RvcmUgcmF3IGFyZ3NcbiAgICB0aGlzLnJhd0FyZ3MgPSBhcmd2O1xuXG4gICAgLy8gZ3Vlc3MgbmFtZVxuICAgIHRoaXMuX25hbWUgPSB0aGlzLl9uYW1lIHx8IHBhdGguYmFzZW5hbWUoYXJndlsxXSwgJy5qcycpO1xuXG4gICAgLy8gZ2l0aHViLXN0eWxlIHN1Yi1jb21tYW5kcyB3aXRoIG5vIHN1Yi1jb21tYW5kXG4gICAgaWYgKHRoaXMuZXhlY3V0YWJsZXMgJiYgYXJndi5sZW5ndGggPCAzICYmICF0aGlzLmRlZmF1bHRFeGVjdXRhYmxlKSB7XG4gICAgICAvLyB0aGlzIHVzZXIgbmVlZHMgaGVscFxuICAgICAgYXJndi5wdXNoKCctLWhlbHAnKTtcbiAgICB9XG5cbiAgICAvLyBwcm9jZXNzIGFyZ3ZcbiAgICBjb25zdCBwYXJzZWQgPSB0aGlzLnBhcnNlT3B0aW9ucyh0aGlzLm5vcm1hbGl6ZShhcmd2LnNsaWNlKDIpKSk7XG4gICAgY29uc3QgYXJncyA9ICh0aGlzLmFyZ3MgPSBwYXJzZWQuYXJncyk7XG5cbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLnBhcnNlQXJncyh0aGlzLmFyZ3MsIHBhcnNlZC51bmtub3duKTtcblxuICAgIC8vIGV4ZWN1dGFibGUgc3ViLWNvbW1hbmRzXG4gICAgY29uc3QgbmFtZSA9IHJlc3VsdC5hcmdzWzBdO1xuXG4gICAgbGV0IGFsaWFzQ29tbWFuZCA9IG51bGw7XG4gICAgLy8gY2hlY2sgYWxpYXMgb2Ygc3ViIGNvbW1hbmRzXG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIGFsaWFzQ29tbWFuZCA9IHRoaXMuY29tbWFuZHMuZmlsdGVyKFxuICAgICAgICBjb21tYW5kID0+IGNvbW1hbmQuZ2V0QWxpYXMoKSA9PT0gbmFtZVxuICAgICAgKVswXTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5leGVjc1tuYW1lXSAmJiB0eXBlb2YgdGhpcy5leGVjc1tuYW1lXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5leGVjdXRlU3ViQ29tbWFuZChhcmd2LCBhcmdzLCBwYXJzZWQudW5rbm93bik7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgaWYgKGFsaWFzQ29tbWFuZCAmJiB0eXBlb2YgYWxpYXNDb21tYW5kLl9uYW1lID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gaXMgYWxpYXMgb2YgYSBzdWJDb21tYW5kXG4gICAgICBhcmdzWzBdID0gYWxpYXNDb21tYW5kLl9uYW1lO1xuICAgICAgdGhpcy5leGVjdXRlU3ViQ29tbWFuZChhcmd2LCBhcmdzLCBwYXJzZWQudW5rbm93bik7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgaWYgKHRoaXMuZGVmYXVsdEV4ZWN1dGFibGUpIHtcbiAgICAgIC8vIHVzZSB0aGUgZGVmYXVsdCBzdWJjb21tYW5kXG4gICAgICBhcmdzLnVuc2hpZnQodGhpcy5kZWZhdWx0RXhlY3V0YWJsZSk7XG4gICAgICB0aGlzLmV4ZWN1dGVTdWJDb21tYW5kKGFyZ3YsIGFyZ3MsIHBhcnNlZC51bmtub3duKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIE91dHB1dCB1bmtub3duIGNvbW1hbmQgZXJyb3JcbiAgICBpZiAoYXJncy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdlcnJvcjogdW5rbm93biBjb21tYW5kICVzJywgYXJnc1swXSk7XG4gICAgICB0aGlzLm91dHB1dEhlbHAoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGUgYSBzdWItY29tbWFuZCBleGVjdXRhYmxlLlxuICAgKlxuICAgKiBAcGFyYW0gYXJndlxuICAgKiBAcGFyYW0gYXJnc1xuICAgKiBAcGFyYW0gdW5rbm93blxuICAgKi9cbiAgcHJpdmF0ZSBleGVjdXRlU3ViQ29tbWFuZChhcmd2OiBzdHJpbmdbXSwgYXJnczogQXJncywgdW5rbm93bjogYW55W10pIHtcbiAgICBhcmdzID0gYXJncy5jb25jYXQodW5rbm93bik7XG5cbiAgICBpZiAoIWFyZ3MubGVuZ3RoKSB0aGlzLmhlbHAoKTtcbiAgICBpZiAoYXJnc1swXSA9PT0gJ2hlbHAnICYmIGFyZ3MubGVuZ3RoID09PSAxKSB0aGlzLmhlbHAoKTtcblxuICAgIC8vIDxjbWQ+IC0taGVscFxuICAgIGlmIChhcmdzWzBdID09PSAnaGVscCcpIHtcbiAgICAgIGFyZ3NbMF0gPSBhcmdzWzFdO1xuICAgICAgYXJnc1sxXSA9ICctLWhlbHAnO1xuICAgIH1cblxuICAgIC8vIGV4ZWN1dGFibGVcbiAgICBjb25zdCBmID0gYXJndlsxXTtcbiAgICAvLyBuYW1lIG9mIHRoZSBzdWJjb21tYW5kLCBsaW5rIGBwbS1pbnN0YWxsYFxuICAgIGxldCBiaW4gPSBgJHtwYXRoLmJhc2VuYW1lKGYsIHBhdGguZXh0bmFtZShmKSl9LSR7YXJnc1swXX1gO1xuXG4gICAgLy8gSW4gY2FzZSBvZiBnbG9iYWxseSBpbnN0YWxsZWQsIGdldCB0aGUgYmFzZSBkaXIgd2hlcmUgZXhlY3V0YWJsZVxuICAgIC8vICBzdWJjb21tYW5kIGZpbGUgc2hvdWxkIGJlIGxvY2F0ZWQgYXRcbiAgICBsZXQgbGluayA9IGZzLmxzdGF0U3luYyhmKS5pc1N5bWJvbGljTGluaygpID8gZnMucmVhZGxpbmtTeW5jKGYpIDogZjtcblxuICAgIC8vIHdoZW4gc3ltYm9saW5rIGlzIHJlbGF0aXZlIHBhdGhcbiAgICBpZiAobGluayAhPT0gZiAmJiBsaW5rLmNoYXJBdCgwKSAhPT0gJy8nKSB7XG4gICAgICBsaW5rID0gcGF0aC5qb2luKHBhdGguZGlybmFtZShmKSwgbGluayk7XG4gICAgfVxuICAgIGNvbnN0IGJhc2VEaXIgPSBwYXRoLmRpcm5hbWUobGluayk7XG5cbiAgICAvLyBwcmVmZXIgbG9jYWwgYC4vPGJpbj5gIHRvIGJpbiBpbiB0aGUgJFBBVEhcbiAgICBjb25zdCBsb2NhbEJpbiA9IHBhdGguam9pbihiYXNlRGlyLCBiaW4pO1xuXG4gICAgLy8gd2hldGhlciBiaW4gZmlsZSBpcyBhIGpzIHNjcmlwdCB3aXRoIGV4cGxpY2l0IGAuanNgIG9yIGAudHNgIGV4dGVuc2lvblxuICAgIGxldCBpc0V4cGxpY2l0SlMgPSBmYWxzZTtcbiAgICBpZiAoZnMuZXhpc3RzU3luYyhgJHtsb2NhbEJpbn0uanNgKSkge1xuICAgICAgYmluID0gYCR7bG9jYWxCaW59LmpzYDtcbiAgICAgIGlzRXhwbGljaXRKUyA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChmcy5leGlzdHNTeW5jKGAke2xvY2FsQmlufS50c2ApKSB7XG4gICAgICBiaW4gPSBgJHtsb2NhbEJpbn0udHNgO1xuICAgICAgaXNFeHBsaWNpdEpTID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGZzLmV4aXN0c1N5bmMobG9jYWxCaW4pKSB7XG4gICAgICBiaW4gPSBsb2NhbEJpbjtcbiAgICB9XG5cbiAgICBhcmdzID0gYXJncy5zbGljZSgxKTtcblxuICAgIGxldCBwcm9jOiBDaGlsZFByb2Nlc3M7XG4gICAgaWYgKHByb2Nlc3MucGxhdGZvcm0gIT09ICd3aW4zMicpIHtcbiAgICAgIGlmIChpc0V4cGxpY2l0SlMpIHtcbiAgICAgICAgYXJncy51bnNoaWZ0KGJpbik7XG4gICAgICAgIC8vIGFkZCBleGVjdXRhYmxlIGFyZ3VtZW50cyB0byBzcGF3blxuICAgICAgICBhcmdzID0gKHByb2Nlc3MuZXhlY0FyZ3YgfHwgW10pLmNvbmNhdChhcmdzKTtcblxuICAgICAgICBwcm9jID0gc3Bhd24ocHJvY2Vzcy5hcmd2WzBdLCBhcmdzLCB7XG4gICAgICAgICAgc3RkaW86ICdpbmhlcml0J1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb2MgPSBzcGF3bihiaW4sIGFyZ3MsIHsgc3RkaW86ICdpbmhlcml0JyB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYXJncy51bnNoaWZ0KGJpbik7XG4gICAgICBwcm9jID0gc3Bhd24ocHJvY2Vzcy5leGVjUGF0aCwgYXJncywgeyBzdGRpbzogJ2luaGVyaXQnIH0pO1xuICAgIH1cblxuICAgIGNvbnN0IHNpZ25hbHM6IE5vZGVKUy5TaWduYWxzW10gPSBbXG4gICAgICAnU0lHVVNSMScsXG4gICAgICAnU0lHVVNSMicsXG4gICAgICAnU0lHVEVSTScsXG4gICAgICAnU0lHSU5UJyxcbiAgICAgICdTSUdIVVAnXG4gICAgXTtcbiAgICBzaWduYWxzLmZvckVhY2goc2lnbmFsID0+IHtcbiAgICAgIHByb2Nlc3Mub24oc2lnbmFsLCAoKSA9PiB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgaWYgKHByb2Mua2lsbGVkID09PSBmYWxzZSAmJiBwcm9jLmV4aXRDb2RlID09IG51bGwpIHtcbiAgICAgICAgICBwcm9jLmtpbGwoc2lnbmFsKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcHJvYy5vbignY2xvc2UnLCBwcm9jZXNzLmV4aXQuYmluZChwcm9jZXNzKSk7XG4gICAgcHJvYy5vbignZXJyb3InLCAoeyBjb2RlIH06IHsgY29kZTogc3RyaW5nIH0pID0+IHtcbiAgICAgIGlmIChjb2RlID09PSAnRU5PRU5UJykge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdlcnJvcjogJXMoMSkgZG9lcyBub3QgZXhpc3QsIHRyeSAtLWhlbHAnLCBiaW4pO1xuICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAnRUFDQ0VTJykge1xuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICdlcnJvcjogJXMoMSkgbm90IGV4ZWN1dGFibGUuIHRyeSBjaG1vZCBvciBydW4gd2l0aCByb290JyxcbiAgICAgICAgICBiaW5cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHByb2Nlc3MuZXhpdCgxKTtcbiAgICB9KTtcblxuICAgIC8vIFN0b3JlIHRoZSByZWZlcmVuY2UgdG8gdGhlIGNoaWxkIHByb2Nlc3NcbiAgICB0aGlzLnJ1bm5pbmdDb21tYW5kID0gcHJvYztcbiAgfVxuXG4gIC8qKlxuICAgKiBOb3JtYWxpemUgYGFyZ3NgLCBzcGxpdHRpbmcgam9pbmVkIHNob3J0IGZsYWdzLiBGb3IgZXhhbXBsZVxuICAgKiB0aGUgYXJnIFwiLWFiY1wiIGlzIGVxdWl2YWxlbnQgdG8gXCItYSAtYiAtY1wiLlxuICAgKiBUaGlzIGFsc28gbm9ybWFsaXplcyBlcXVhbCBzaWduIGFuZCBzcGxpdHMgXCItLWFiYz1kZWZcIiBpbnRvIFwiLS1hYmMgZGVmXCIuXG4gICAqXG4gICAqIEBwYXJhbSBhcmdzXG4gICAqIEByZXR1cm5zIGFycmF5IG9mIG5vcm1hbGl6ZWQgYGFyZ3NgXG4gICAqL1xuICBwcml2YXRlIG5vcm1hbGl6ZShhcmdzOiBBcmdzKTogQXJncyB7XG4gICAgbGV0IHJldCA9IFtdO1xuICAgIGxldCBhcmc7XG4gICAgbGV0IGxhc3RPcHQ7XG4gICAgbGV0IGluZGV4O1xuXG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGFyZ3MubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIGFyZyA9IGFyZ3NbaV07XG4gICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgbGFzdE9wdCA9IHRoaXMub3B0aW9uRm9yKGFyZ3NbaSAtIDFdKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFyZyA9PT0gJy0tJykge1xuICAgICAgICAvLyBIb25vciBvcHRpb24gdGVybWluYXRvclxuICAgICAgICByZXQgPSByZXQuY29uY2F0KGFyZ3Muc2xpY2UoaSkpO1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSBpZiAobGFzdE9wdCAmJiBsYXN0T3B0LnJlcXVpcmVkKSB7XG4gICAgICAgIHJldC5wdXNoKGFyZyk7XG4gICAgICB9IGVsc2UgaWYgKGFyZy5sZW5ndGggPiAxICYmIGFyZ1swXSA9PT0gJy0nICYmIGFyZ1sxXSAhPT0gJy0nKSB7XG4gICAgICAgIGFyZ1xuICAgICAgICAgIC5zbGljZSgxKVxuICAgICAgICAgIC5zcGxpdCgnJylcbiAgICAgICAgICAuZm9yRWFjaChjID0+IHtcbiAgICAgICAgICAgIHJldC5wdXNoKGAtJHtjfWApO1xuICAgICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmICgvXi0tLy50ZXN0KGFyZykgJiYgfihpbmRleCA9IGFyZy5pbmRleE9mKCc9JykpKSB7XG4gICAgICAgIHJldC5wdXNoKGFyZy5zbGljZSgwLCBpbmRleCksIGFyZy5zbGljZShpbmRleCArIDEpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldC5wdXNoKGFyZyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZSBjb21tYW5kIGBhcmdzYC5cbiAgICpcbiAgICogV2hlbiBsaXN0ZW5lcihzKSBhcmUgYXZhaWxhYmxlIHRob3NlXG4gICAqIGNhbGxiYWNrcyBhcmUgaW52b2tlZCwgb3RoZXJ3aXNlIHRoZSBcIipcIlxuICAgKiBldmVudCBpcyBlbWl0dGVkIGFuZCB0aG9zZSBhY3Rpb25zIGFyZSBpbnZva2VkLlxuICAgKlxuICAgKiBAcGFyYW0gYXJnc1xuICAgKiBAcmV0dXJucyBbW0NvbW1hbmRdXSBmb3IgY2hhaW5pbmdcbiAgICovXG4gIHByaXZhdGUgcGFyc2VBcmdzKGFyZ3M6IHN0cmluZ1tdLCB1bmtub3duOiBhbnkpOiBDb21tYW5kIHtcbiAgICBsZXQgbmFtZTtcblxuICAgIGlmIChhcmdzLmxlbmd0aCkge1xuICAgICAgbmFtZSA9IGFyZ3NbMF07XG4gICAgICBpZiAodGhpcy5saXN0ZW5lcnMoYGNvbW1hbmQ6JHtuYW1lfWApLmxlbmd0aCkge1xuICAgICAgICB0aGlzLmVtaXQoYGNvbW1hbmQ6JHthcmdzLnNoaWZ0KCl9YCwgYXJncywgdW5rbm93bik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmVtaXQoJ2NvbW1hbmQ6KicsIGFyZ3MpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXRIZWxwSWZOZWNlc3NhcnkodGhpcywgdW5rbm93bik7XG5cbiAgICAgIC8vIElmIHRoZXJlIHdlcmUgbm8gYXJncyBhbmQgd2UgaGF2ZSB1bmtub3duIG9wdGlvbnMsXG4gICAgICAvLyB0aGVuIHRoZXkgYXJlIGV4dHJhbmVvdXMgYW5kIHdlIG5lZWQgdG8gZXJyb3IuXG4gICAgICBpZiAodW5rbm93bi5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMudW5rbm93bk9wdGlvbih1bmtub3duWzBdKTtcbiAgICAgIH1cbiAgICAgIGlmIChcbiAgICAgICAgdGhpcy5jb21tYW5kcy5sZW5ndGggPT09IDAgJiZcbiAgICAgICAgdGhpcy5fYXJncy5maWx0ZXIoKHsgcmVxdWlyZWQgfSkgPT4gcmVxdWlyZWQpLmxlbmd0aCA9PT0gMFxuICAgICAgKSB7XG4gICAgICAgIHRoaXMuZW1pdCgnY29tbWFuZDoqJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGFuIFtbT3B0aW9uXV0gbWF0Y2hpbmcgYGFyZ2AgaWYgYW55LlxuICAgKlxuICAgKiBAcGFyYW0gYXJnXG4gICAqIEByZXR1cm5zIGFuIFtbT3B0aW9uXV0gbWF0Y2hpbmcgYGFyZ2AgaWYgYW55LlxuICAgKi9cbiAgcHJpdmF0ZSBvcHRpb25Gb3IoYXJnOiBzdHJpbmcpOiBPcHRpb24gfCB1bmRlZmluZWQge1xuICAgIGNvbnN0IG9wdGlvbiA9IHRoaXMub3B0aW9ucy5maW5kKG9wdGlvbiA9PiBvcHRpb24uaXMoYXJnKSk7XG4gICAgcmV0dXJuIG9wdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZSBvcHRpb25zIGZyb20gYGFyZ3ZgIHJldHVybmluZyBgYXJndmAgdm9pZCBvZiB0aGVzZSBvcHRpb25zLlxuICAgKlxuICAgKiBAcGFyYW0gYXJndlxuICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAqL1xuICBwcml2YXRlIHBhcnNlT3B0aW9ucyhhcmd2OiBBcmdzKTogeyBhcmdzOiBBcmdzOyB1bmtub3duOiBBcmdzIH0ge1xuICAgIGNvbnN0IGFyZ3MgPSBbXTtcbiAgICBjb25zdCBsZW4gPSBhcmd2Lmxlbmd0aDtcbiAgICBsZXQgbGl0ZXJhbDtcbiAgICBsZXQgb3B0aW9uO1xuICAgIGxldCBhcmc7XG5cbiAgICBjb25zdCB1bmtub3duT3B0aW9ucyA9IFtdO1xuXG4gICAgLy8gcGFyc2Ugb3B0aW9uc1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIGFyZyA9IGFyZ3ZbaV07XG5cbiAgICAgIC8vIGxpdGVyYWwgYXJncyBhZnRlciAtLVxuICAgICAgaWYgKGxpdGVyYWwpIHtcbiAgICAgICAgYXJncy5wdXNoKGFyZyk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoYXJnID09PSAnLS0nKSB7XG4gICAgICAgIGxpdGVyYWwgPSB0cnVlO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gZmluZCBtYXRjaGluZyBPcHRpb25cbiAgICAgIG9wdGlvbiA9IHRoaXMub3B0aW9uRm9yKGFyZyk7XG5cbiAgICAgIC8vIG9wdGlvbiBpcyBkZWZpbmVkXG4gICAgICBpZiAob3B0aW9uKSB7XG4gICAgICAgIC8vIHJlcXVpcmVzIGFyZ1xuICAgICAgICBpZiAob3B0aW9uLnJlcXVpcmVkKSB7XG4gICAgICAgICAgYXJnID0gYXJndlsrK2ldO1xuICAgICAgICAgIGlmIChhcmcgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25NaXNzaW5nQXJndW1lbnQob3B0aW9uKTtcbiAgICAgICAgICAgIHJldHVybiB7IGFyZ3M6IFtdLCB1bmtub3duOiBbXSB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmVtaXQoYG9wdGlvbjoke29wdGlvbi5uYW1lKCl9YCwgYXJnKTtcbiAgICAgICAgICAvLyBvcHRpb25hbCBhcmdcbiAgICAgICAgfSBlbHNlIGlmIChvcHRpb24ub3B0aW9uYWwpIHtcbiAgICAgICAgICBhcmcgPSBhcmd2W2kgKyAxXTtcbiAgICAgICAgICAvLyBubyBhcmcgcHJvdmlkZWRcbiAgICAgICAgICBpZiAoYXJnID09IG51bGwgfHwgKGFyZyAmJiBhcmdbMF0gPT09ICctJyAmJiBhcmcgIT09ICctJykpIHtcbiAgICAgICAgICAgIGFyZyA9IG51bGw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICsraTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5lbWl0KGBvcHRpb246JHtvcHRpb24ubmFtZSgpfWAsIGFyZyk7XG4gICAgICAgICAgLy8gYm9vbFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZW1pdChgb3B0aW9uOiR7b3B0aW9uLm5hbWUoKX1gKTtcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gbG9va3MgbGlrZSBhbiBvcHRpb25cbiAgICAgIGlmIChhcmcubGVuZ3RoID4gMSAmJiBhcmdbMF0gPT09ICctJykge1xuICAgICAgICB1bmtub3duT3B0aW9ucy5wdXNoKGFyZyk7XG5cbiAgICAgICAgLy8gSWYgdGhlIG5leHQgYXJndW1lbnQgbG9va3MgbGlrZSBpdCBtaWdodCBiZVxuICAgICAgICAvLyBhbiBhcmd1bWVudCBmb3IgdGhpcyBvcHRpb24sIHdlIHBhc3MgaXQgb24uXG4gICAgICAgIC8vIElmIGl0IGlzbid0LCB0aGVuIGl0J2xsIHNpbXBseSBiZSBpZ25vcmVkXG4gICAgICAgIGlmIChpICsgMSA8IGFyZ3YubGVuZ3RoICYmIGFyZ3ZbaSArIDFdWzBdICE9PSAnLScpIHtcbiAgICAgICAgICB1bmtub3duT3B0aW9ucy5wdXNoKGFyZ3ZbKytpXSk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIGFyZ1xuICAgICAgYXJncy5wdXNoKGFyZyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgYXJncywgdW5rbm93bjogdW5rbm93bk9wdGlvbnMgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYW4gb2JqZWN0IGNvbnRhaW5pbmcgb3B0aW9ucyBhcyBrZXktdmFsdWUgcGFpcnNcbiAgICpcbiAgICogQHJldHVybnMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgb3B0aW9ucyBhcyBrZXktdmFsdWUgcGFpcnNcbiAgICovXG4gIHB1YmxpYyBvcHRzKCk6IFJlY29yZDxzdHJpbmcsIGFueT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGNvbnN0IGxlbiA9IHRoaXMub3B0aW9ucy5sZW5ndGg7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBjb25zdCBrZXkgPSB0aGlzLm9wdGlvbnNbaV0uYXR0cmlidXRlTmFtZSgpO1xuICAgICAgcmVzdWx0W2tleV0gPSBrZXkgPT09IHRoaXMudmVyc2lvbk9wdGlvbk5hbWUgPyB0aGlzLl92ZXJzaW9uIDogdGhpc1trZXldO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogTG9nIGVycm9yIHdoZW4gcmd1bWVudCBgbmFtZWAgaXMgbWlzc2luZy5cbiAgICpcbiAgICogQHBhcmFtIG5hbWVcbiAgICovXG4gIHByaXZhdGUgbWlzc2luZ0FyZ3VtZW50KG5hbWU6IHN0cmluZyk6IHZvaWQge1xuICAgIGNvbnNvbGUuZXJyb3IoJ2Vycm9yOiBtaXNzaW5nIHJlcXVpcmVkIGFyZ3VtZW50IGAlc2AnLCBuYW1lKTtcbiAgICBwcm9jZXNzLmV4aXQoMSk7XG4gIH1cblxuICAvKipcbiAgICogTG9nIGVycm9yIHdoZW4gW1tPcHRpb25dXSBpcyBtaXNzaW5nIGFuIGFyZ3VtZW50LCBidXQgcmVjZWl2ZWQgYGZsYWdgIG9yIG5vdGhpbmcuXG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25cbiAgICogQHBhcmFtIGZsYWdcbiAgICovXG4gIHByaXZhdGUgb3B0aW9uTWlzc2luZ0FyZ3VtZW50KHsgZmxhZ3MgfTogT3B0aW9uLCBmbGFnPzogc3RyaW5nKTogdm9pZCB7XG4gICAgaWYgKGZsYWcpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICdlcnJvcjogb3B0aW9uIGAlc2AgYXJndW1lbnQgbWlzc2luZywgZ290IGAlc2AnLFxuICAgICAgICBmbGFncyxcbiAgICAgICAgZmxhZ1xuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5lcnJvcignZXJyb3I6IG9wdGlvbiBgJXNgIGFyZ3VtZW50IG1pc3NpbmcnLCBmbGFncyk7XG4gICAgfVxuICAgIHByb2Nlc3MuZXhpdCgxKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2cgZXJyb3Igd2hlbiByZWNlaXZlZCB1bmtub3duIG9wdGlvbiBgZmxhZ2BcbiAgICpcbiAgICogQHBhcmFtIGZsYWdcbiAgICovXG4gIHByaXZhdGUgdW5rbm93bk9wdGlvbihmbGFnOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5fYWxsb3dVbmtub3duT3B0aW9uKSByZXR1cm47XG4gICAgY29uc29sZS5lcnJvcignZXJyb3I6IHVua25vd24gb3B0aW9uIGAlc2AnLCBmbGFnKTtcbiAgICBwcm9jZXNzLmV4aXQoMSk7XG4gIH1cblxuICAvKipcbiAgICogVmFyaWFkaWMgYXJndW1lbnQgd2l0aCBgbmFtZWAgaXMgbm90IHRoZSBsYXN0IGFyZ3VtZW50IGFzIHJlcXVpcmVkLlxuICAgKlxuICAgKiBAcGFyYW0gbmFtZVxuICAgKi9cbiAgcHJpdmF0ZSB2YXJpYWRpY0FyZ05vdExhc3QobmFtZTogc3RyaW5nKTogdm9pZCB7XG4gICAgY29uc29sZS5lcnJvcignZXJyb3I6IHZhcmlhZGljIGFyZ3VtZW50cyBtdXN0IGJlIGxhc3QgYCVzYCcsIG5hbWUpO1xuICAgIHByb2Nlc3MuZXhpdCgxKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHByb2dyYW0gdmVyc2lvblxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBhdXRvLXJlZ2lzdGVycyB0aGUgXCItViwgLS12ZXJzaW9uXCIgZmxhZ1xuICAgKiB3aGljaCB3aWxsIHByaW50IHRoZSB2ZXJzaW9uIG51bWJlciB3aGVuIHBhc3NlZC5cbiAgICpcbiAgICogQHBhcmFtIHZlcnNpb25cbiAgICogQHBhcmFtIFtmbGFnc11cbiAgICogQHJldHVybnMgW1tDb21tYW5kXV0gZm9yIGNoYWluaW5nXG4gICAqL1xuICBwdWJsaWMgdmVyc2lvbih2ZXJzaW9uOiBzdHJpbmcsIGZsYWdzPzogc3RyaW5nKTogQ29tbWFuZCB7XG4gICAgdGhpcy5fdmVyc2lvbiA9IHZlcnNpb247XG4gICAgZmxhZ3MgPSBmbGFncyB8fCAnLVYsIC0tdmVyc2lvbic7XG4gICAgY29uc3QgdmVyc2lvbk9wdGlvbiA9IG5ldyBPcHRpb24oZmxhZ3MsICdvdXRwdXQgdGhlIHZlcnNpb24gbnVtYmVyJyk7XG4gICAgdGhpcy52ZXJzaW9uT3B0aW9uTmFtZSA9IHZlcnNpb25PcHRpb24ubG9uZy5zdWJzdHIoMikgfHwgJ3ZlcnNpb24nO1xuICAgIHRoaXMub3B0aW9ucy5wdXNoKHZlcnNpb25PcHRpb24pO1xuICAgIHRoaXMub24oYG9wdGlvbjoke3RoaXMudmVyc2lvbk9wdGlvbk5hbWV9YCwgKCkgPT4ge1xuICAgICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoYCR7dmVyc2lvbn1cXG5gKTtcbiAgICAgIHByb2Nlc3MuZXhpdCgwKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGNvbW1hbmQgZGVzY3JpcHRpb25cbiAgICpcbiAgICogQHBhcmFtIHN0ciAtIHRoZSBkZXNjcmlwdGlvbiBmb3IgdGhlIGNvbW1hbmRcbiAgICogQHBhcmFtIGFyZ3NEZXNjcmlwdGlvblxuICAgKiBAcmV0dXJucyBbW0NvbW1hbmRdXSBmb3IgY2hhaW5pbmdcbiAgICovXG4gIHB1YmxpYyBkZXNjcmlwdGlvbihcbiAgICBzdHI6IHN0cmluZyxcbiAgICBhcmdzRGVzY3JpcHRpb24/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+XG4gICk6IENvbW1hbmQge1xuICAgIHRoaXMuX2Rlc2NyaXB0aW9uID0gc3RyO1xuICAgIHRoaXMuYXJnc0Rlc2NyaXB0aW9uID0gYXJnc0Rlc2NyaXB0aW9uO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCBhbiBhbGlhcyBmb3IgdGhlIGNvbW1hbmRcbiAgICpcbiAgICogQHBhcmFtIGFsaWFzIC0gd2hhdCB0byBhbGlhcyB0aGUgY29tbWFuZCB0b1xuICAgKiBAcmV0dXJucyBbW0NvbW1hbmRdXSBmb3IgY2hhaW5pbmdcbiAgICovXG4gIHB1YmxpYyBhbGlhcyhhbGlhczogc3RyaW5nKTogQ29tbWFuZCB7XG4gICAgbGV0IGNvbW1hbmQ6IENvbW1hbmQgPSB0aGlzO1xuICAgIGlmICh0aGlzLmNvbW1hbmRzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgY29tbWFuZCA9IHRoaXMuY29tbWFuZHNbdGhpcy5jb21tYW5kcy5sZW5ndGggLSAxXTtcbiAgICB9XG5cbiAgICBpZiAoYWxpYXMgPT09IGNvbW1hbmQuX25hbWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvbW1hbmQgYWxpYXMgY2FuJ3QgYmUgdGhlIHNhbWUgYXMgaXRzIG5hbWVcIik7XG4gICAgfVxuICAgIGlmIChhbGlhcykge1xuICAgICAgY29tbWFuZC5fYWxpYXMgPSBhbGlhcztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGFsaWFzIGZvciB0aGUgY29tbWFuZFxuICAgKlxuICAgKiBAcGFyYW0gYWxpYXMgLSB3aGF0IHRvIGFsaWFzIHRoZSBjb21tYW5kIHRvXG4gICAqIEByZXR1cm5zIHRoZSBhbGlhc1xuICAgKi9cbiAgcHJpdmF0ZSBnZXRBbGlhcygpOiBzdHJpbmcge1xuICAgIGxldCBjb21tYW5kOiBDb21tYW5kID0gdGhpcztcbiAgICBpZiAodGhpcy5jb21tYW5kcy5sZW5ndGggIT09IDApIHtcbiAgICAgIGNvbW1hbmQgPSB0aGlzLmNvbW1hbmRzW3RoaXMuY29tbWFuZHMubGVuZ3RoIC0gMV07XG4gICAgfVxuICAgIHJldHVybiBjb21tYW5kLl9hbGlhcztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGNvbW1hbmQgdXNhZ2VcbiAgICpcbiAgICogQHBhcmFtIHN0clxuICAgKiBAcmV0dXJucyBbW0NvbW1hbmRdXSBmb3IgY2hhaW5pbmdcbiAgICovXG4gIHB1YmxpYyB1c2FnZSh1c2FnZTogc3RyaW5nKTogc3RyaW5nIHwgQ29tbWFuZCB7XG4gICAgdGhpcy5fdXNhZ2UgPSB1c2FnZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHVzYWdlIHByb21wdCBhcyBhIHN0cmluZ1xuICAgKi9cbiAgcHJpdmF0ZSBnZXRVc2FnZSgpOiBzdHJpbmcge1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9hcmdzLm1hcChhcmcgPT4gaHVtYW5SZWFkYWJsZUFyZ05hbWUoYXJnKSk7XG5cbiAgICBjb25zdCB1c2FnZSA9IGBbb3B0aW9uc10ke3RoaXMuY29tbWFuZHMubGVuZ3RoID8gJyBbY29tbWFuZF0nIDogJyd9JHtcbiAgICAgIHRoaXMuX2FyZ3MubGVuZ3RoID8gYCAke2FyZ3Muam9pbignICcpfWAgOiAnJ1xuICAgIH1gO1xuXG4gICAgcmV0dXJuIHRoaXMuX3VzYWdlIHx8IHVzYWdlO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgbmFtZSBvZiB0aGUgY29tbWFuZFxuICAgKlxuICAgKiBAcGFyYW0gc3RyXG4gICAqIEByZXR1cm5zIFtbQ29tbWFuZF1dIGZvciBjaGFpbmluZ1xuICAgKi9cbiAgcHVibGljIG5hbWUoc3RyOiBzdHJpbmcpOiBDb21tYW5kIHtcbiAgICB0aGlzLl9uYW1lID0gc3RyO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbmFtZSBvZiB0aGUgY29tbWFuZFxuICAgKlxuICAgKiBAcGFyYW0gc3RyXG4gICAqIEByZXR1cm5zIHRoZSBuYW1lIG9mIHRoZSBjb21tYW5kXG4gICAqL1xuICBwcml2YXRlIGdldE5hbWUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5fbmFtZSB8fCAnJztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgcHJlcGFyZWQgY29tbWFuZHMuXG4gICAqXG4gICAqIEByZXR1cm5zIHByZXBhcmVkIGNvbW1hbmRzXG4gICAqL1xuICBwcml2YXRlIHByZXBhcmVDb21tYW5kcygpOiBzdHJpbmdbXVtdIHtcbiAgICByZXR1cm4gdGhpcy5jb21tYW5kc1xuICAgICAgLmZpbHRlcigoeyBub0hlbHAgfSkgPT4gIW5vSGVscClcbiAgICAgIC5tYXAoY21kID0+IHtcbiAgICAgICAgY29uc3QgYXJncyA9IGNtZC5fYXJncy5tYXAoYXJnID0+IGh1bWFuUmVhZGFibGVBcmdOYW1lKGFyZykpLmpvaW4oJyAnKTtcblxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgIGNtZC5fbmFtZSArXG4gICAgICAgICAgICAoY21kLl9hbGlhcyA/IGB8JHtjbWQuX2FsaWFzfWAgOiAnJykgK1xuICAgICAgICAgICAgKGNtZC5vcHRpb25zLmxlbmd0aCA/ICcgW29wdGlvbnNdJyA6ICcnKSArXG4gICAgICAgICAgICAoYXJncyA/IGAgJHthcmdzfWAgOiAnJyksXG4gICAgICAgICAgY21kLl9kZXNjcmlwdGlvblxuICAgICAgICBdO1xuICAgICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBsYXJnZXN0IGNvbW1hbmQgbGVuZ3RoLlxuICAgKlxuICAgKiBAcmV0dXJucyB0aGUgbGFyZ2VzdCBjb21tYW5kIGxlbmd0aFxuICAgKi9cbiAgcHJpdmF0ZSBsYXJnZXN0Q29tbWFuZExlbmd0aCgpIHtcbiAgICBjb25zdCBjb21tYW5kcyA9IHRoaXMucHJlcGFyZUNvbW1hbmRzKCk7XG4gICAgcmV0dXJuIGNvbW1hbmRzLnJlZHVjZShcbiAgICAgIChtYXgsIGNvbW1hbmQpID0+IE1hdGgubWF4KG1heCwgY29tbWFuZFswXS5sZW5ndGgpLFxuICAgICAgMFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBsYXJnZXN0IG9wdGlvbiBsZW5ndGguXG4gICAqXG4gICAqIEByZXR1cm5zIHRoZSBsYXJnZXN0IG9wdGlvbiBsZW5ndGhcbiAgICovXG4gIHByaXZhdGUgbGFyZ2VzdE9wdGlvbkxlbmd0aCgpOiBudW1iZXIge1xuICAgIGNvbnN0IG9wdGlvbnMgPSBbXS5zbGljZS5jYWxsKHRoaXMub3B0aW9ucyk7XG4gICAgb3B0aW9ucy5wdXNoKHtcbiAgICAgIGZsYWdzOiAnLWgsIC0taGVscCdcbiAgICB9KTtcbiAgICByZXR1cm4gb3B0aW9ucy5yZWR1Y2UoXG4gICAgICAobWF4OiBudW1iZXIsIHsgZmxhZ3MgfTogeyBmbGFnczogc3RyaW5nIH0pID0+XG4gICAgICAgIE1hdGgubWF4KG1heCwgZmxhZ3MubGVuZ3RoKSxcbiAgICAgIDBcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbGFyZ2VzdCBhcmcgbGVuZ3RoLlxuICAgKlxuICAgKiBAcmV0dXJucyB0aGUgbGFyZ2VzdCBhcmcgbGVuZ3RoXG4gICAqL1xuICBwcml2YXRlIGxhcmdlc3RBcmdMZW5ndGgoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5fYXJncy5yZWR1Y2UoXG4gICAgICAobWF4OiBudW1iZXIsIHsgbmFtZSB9OiB7IG5hbWU6IHN0cmluZyB9KSA9PiBNYXRoLm1heChtYXgsIG5hbWUubGVuZ3RoKSxcbiAgICAgIDBcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgcGFkIHdpZHRoLlxuICAgKlxuICAgKiBAcmV0dXJucyB0aGUgcGFkIHdpZHRoXG4gICAqL1xuICBwcml2YXRlIHBhZFdpZHRoKCk6IG51bWJlciB7XG4gICAgbGV0IHdpZHRoID0gdGhpcy5sYXJnZXN0T3B0aW9uTGVuZ3RoKCk7XG4gICAgaWYgKHRoaXMuYXJnc0Rlc2NyaXB0aW9uICYmIHRoaXMuX2FyZ3MubGVuZ3RoKSB7XG4gICAgICBpZiAodGhpcy5sYXJnZXN0QXJnTGVuZ3RoKCkgPiB3aWR0aCkge1xuICAgICAgICB3aWR0aCA9IHRoaXMubGFyZ2VzdEFyZ0xlbmd0aCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLmNvbW1hbmRzICYmIHRoaXMuY29tbWFuZHMubGVuZ3RoKSB7XG4gICAgICBpZiAodGhpcy5sYXJnZXN0Q29tbWFuZExlbmd0aCgpID4gd2lkdGgpIHtcbiAgICAgICAgd2lkdGggPSB0aGlzLmxhcmdlc3RDb21tYW5kTGVuZ3RoKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHdpZHRoO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBoZWxwIGZvciBvcHRpb25zLlxuICAgKlxuICAgKiBAcmV0dXJucyBoZWxwIG9wdGlvbnMgYXMgYSBzdHJpbmdcbiAgICovXG4gIHByaXZhdGUgb3B0aW9uSGVscCgpOiBzdHJpbmcge1xuICAgIGNvbnN0IHdpZHRoID0gdGhpcy5wYWRXaWR0aCgpO1xuXG4gICAgLy8gQXBwZW5kIHRoZSBoZWxwIGluZm9ybWF0aW9uXG4gICAgcmV0dXJuIHRoaXMub3B0aW9uc1xuICAgICAgLm1hcChcbiAgICAgICAgKHsgZmxhZ3MsIGRlc2NyaXB0aW9uLCBib29sLCBkZWZhdWx0VmFsdWUgfSkgPT5cbiAgICAgICAgICBgJHtwYWQoZmxhZ3MsIHdpZHRoKX0gICR7ZGVzY3JpcHRpb259JHtcbiAgICAgICAgICAgIGJvb2wgJiYgZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgPyBgIChkZWZhdWx0OiAke0pTT04uc3RyaW5naWZ5KGRlZmF1bHRWYWx1ZSl9KWBcbiAgICAgICAgICAgICAgOiAnJ1xuICAgICAgICAgIH1gXG4gICAgICApXG4gICAgICAuY29uY2F0KFtgJHtgJHtwYWQoJy1oLCAtLWhlbHAnLCB3aWR0aCl9ICBgfW91dHB1dCB1c2FnZSBpbmZvcm1hdGlvbmBdKVxuICAgICAgLmpvaW4oJ1xcbicpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBjb21tYW5kIGhlbHAgZG9jdW1lbnRhdGlvbi5cbiAgICpcbiAgICogQHJldHVybnMgY29tbWFuZCBoZWxwIGRvY3VtZW50YXRpb25cbiAgICovXG4gIHByaXZhdGUgY29tbWFuZEhlbHAoKTogc3RyaW5nIHtcbiAgICBpZiAoIXRoaXMuY29tbWFuZHMubGVuZ3RoKSByZXR1cm4gJyc7XG5cbiAgICBjb25zdCBjb21tYW5kcyA9IHRoaXMucHJlcGFyZUNvbW1hbmRzKCk7XG4gICAgY29uc3Qgd2lkdGggPSB0aGlzLnBhZFdpZHRoKCk7XG5cbiAgICByZXR1cm4gW1xuICAgICAgJ0NvbW1hbmRzOicsXG4gICAgICBjb21tYW5kc1xuICAgICAgICAubWFwKGNtZCA9PiB7XG4gICAgICAgICAgY29uc3QgZGVzYyA9IGNtZFsxXSA/IGAgICR7Y21kWzFdfWAgOiAnJztcbiAgICAgICAgICByZXR1cm4gKGRlc2MgPyBwYWQoY21kWzBdLCB3aWR0aCkgOiBjbWRbMF0pICsgZGVzYztcbiAgICAgICAgfSlcbiAgICAgICAgLmpvaW4oJ1xcbicpXG4gICAgICAgIC5yZXBsYWNlKC9eL2dtLCAnICAnKSxcbiAgICAgICcnXG4gICAgXS5qb2luKCdcXG4nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgcHJvZ3JhbSBoZWxwIGRvY3VtZW50YXRpb24uXG4gICAqXG4gICAqIEByZXR1cm5zIHByb2dyYW0gaGVscCBkb2N1bWVudGF0aW9uXG4gICAqL1xuICBwcml2YXRlIGhlbHBJbmZvcm1hdGlvbigpOiBzdHJpbmcge1xuICAgIGxldCBkZXNjOiBzdHJpbmdbXSA9IFtdO1xuICAgIGlmICh0aGlzLl9kZXNjcmlwdGlvbikge1xuICAgICAgZGVzYyA9IFt0aGlzLl9kZXNjcmlwdGlvbiwgJyddO1xuXG4gICAgICBjb25zdCB7IGFyZ3NEZXNjcmlwdGlvbiB9ID0gdGhpcztcbiAgICAgIGlmIChhcmdzRGVzY3JpcHRpb24gJiYgdGhpcy5fYXJncy5sZW5ndGgpIHtcbiAgICAgICAgY29uc3Qgd2lkdGggPSB0aGlzLnBhZFdpZHRoKCk7XG4gICAgICAgIGRlc2MucHVzaCgnQXJndW1lbnRzOicpO1xuICAgICAgICBkZXNjLnB1c2goJycpO1xuICAgICAgICB0aGlzLl9hcmdzLmZvckVhY2goKHsgbmFtZSB9KSA9PiB7XG4gICAgICAgICAgZGVzYy5wdXNoKGAgICR7cGFkKG5hbWUsIHdpZHRoKX0gICR7YXJnc0Rlc2NyaXB0aW9uW25hbWVdfWApO1xuICAgICAgICB9KTtcbiAgICAgICAgZGVzYy5wdXNoKCcnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgY21kTmFtZSA9IHRoaXMuX25hbWU7XG4gICAgaWYgKHRoaXMuX2FsaWFzKSB7XG4gICAgICBjbWROYW1lID0gYCR7Y21kTmFtZX18JHt0aGlzLl9hbGlhc31gO1xuICAgIH1cbiAgICBjb25zdCB1c2FnZSA9IFtgVXNhZ2U6ICR7Y21kTmFtZX0gJHt0aGlzLmdldFVzYWdlKCl9YCwgJyddO1xuXG4gICAgbGV0IGNtZHM6IHN0cmluZ1tdID0gW107XG4gICAgY29uc3QgY29tbWFuZEhlbHAgPSB0aGlzLmNvbW1hbmRIZWxwKCk7XG4gICAgaWYgKGNvbW1hbmRIZWxwKSBjbWRzID0gW2NvbW1hbmRIZWxwXTtcblxuICAgIGNvbnN0IG9wdGlvbnMgPSBbXG4gICAgICAnT3B0aW9uczonLFxuICAgICAgYCR7dGhpcy5vcHRpb25IZWxwKCkucmVwbGFjZSgvXi9nbSwgJyAgJyl9YCxcbiAgICAgICcnXG4gICAgXTtcblxuICAgIHJldHVybiB1c2FnZVxuICAgICAgLmNvbmNhdChkZXNjKVxuICAgICAgLmNvbmNhdChvcHRpb25zKVxuICAgICAgLmNvbmNhdChjbWRzKVxuICAgICAgLmpvaW4oJ1xcbicpO1xuICB9XG5cbiAgLyoqXG4gICAqIE91dHB1dCBoZWxwIGluZm9ybWF0aW9uIGZvciB0aGlzIGNvbW1hbmRcbiAgICovXG4gIHB1YmxpYyBvdXRwdXRIZWxwKGNiPzogKGE6IHN0cmluZykgPT4gc3RyaW5nKSB7XG4gICAgaWYgKCFjYikge1xuICAgICAgY2IgPSBwYXNzdGhydSA9PiBwYXNzdGhydTtcbiAgICB9XG4gICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoY2IodGhpcy5oZWxwSW5mb3JtYXRpb24oKSkpO1xuICAgIHRoaXMuZW1pdCgnLS1oZWxwJyk7XG4gIH1cblxuICAvKipcbiAgICogT3V0cHV0IGhlbHAgaW5mb3JtYXRpb24gYW5kIGV4aXQuXG4gICAqL1xuICBwdWJsaWMgaGVscChjYj86IChhOiBzdHJpbmcpID0+IHN0cmluZykge1xuICAgIHRoaXMub3V0cHV0SGVscChjYik7XG4gICAgcHJvY2Vzcy5leGl0KDEpO1xuICB9XG59XG5cbi8qKlxuICogRXhwb3NlIHRoZSByb290IGNvbW1hbmQuXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQ29tbWFuZEZhY3RvcnkobmFtZT86IHN0cmluZykge1xuICByZXR1cm4gbmV3IENvbW1hbmQobmFtZSk7XG59XG4iXX0=